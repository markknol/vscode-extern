<haxe>
	<abstract path="Any" params="" file="/home/travis/haxe/std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<impl><class path="_Any.Any_Impl_" params="" file="/home/travis/haxe/std/Any.hx" private="1" module="Any"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="Array" params="T" file="/home/travis/haxe/std/js/_std/Array.hx" extern="1">
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see http://haxe.org/manual/std-Array.html
	@see http://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/home/travis/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see http://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="Date" params="" file="/home/travis/haxe/std/js/_std/Date.hx" extern="1">
		<now public="1" get="inline" set="null" line="38" static="1">
			<f a=""><c path="Date"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date representing the current local time.</haxe_doc>
		</now>
		<fromTime public="1" get="inline" set="null" line="42" static="1">
			<f a="t">
				<x path="Float"/>
				<c path="Date"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date from timestamp `t`.</haxe_doc>
		</fromTime>
		<fromString public="1" get="inline" set="null" line="46" static="1">
			<f a="s">
				<c path="String"/>
				<c path="Date"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a Date from a formated string `s`, with the following accepted
		formats:

		- `"YYYY-MM-DD hh:mm:ss"`
		- `"YYYY-MM-DD"`
		- `"hh:mm:ss"`

		The first two formats are expressed in local time, the third in UTC
		Epoch.</haxe_doc>
		</fromString>
		<getTime public="1" set="method">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns the timestamp of the date. It might only have a per-second
		precision depending on the platforms.</haxe_doc>
		</getTime>
		<getHours public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the hours of `this` Date (0-23 range).</haxe_doc>
		</getHours>
		<getMinutes public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the minutes of `this` Date (0-59 range).</haxe_doc>
		</getMinutes>
		<getSeconds public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the seconds of the `this` Date (0-59 range).</haxe_doc>
		</getSeconds>
		<getFullYear public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the full year of `this` Date (4-digits).</haxe_doc>
		</getFullYear>
		<getMonth public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the month of `this` Date (0-11 range).</haxe_doc>
		</getMonth>
		<getDate public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of `this` Date (1-31 range).</haxe_doc>
		</getDate>
		<getDay public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Returns the day of the week of `this` Date (0-6 range).</haxe_doc>
		</getDay>
		<toString public="1" get="inline" set="null" line="34">
			<f a=""><c path="String"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns a string representation of `this` Date, by using the
		standard format [YYYY-MM-DD HH:MM:SS]. See `DateTools.format` for
		other formating rules.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="year:month:day:hour:min:sec">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new date object from the given arguments.

		The behaviour of a Date instance is only consistent across platforms if
		the the arguments describe a valid date.

		- month: 0 to 11
		- day: 1 to 31
		- hour: 0 to 23
		- min: 0 to 59
		- sec: 0 to 59</haxe_doc>
		</new>
		<haxe_doc>The Date class provides a basic structure for date and time related
	information. Date instances can be created by

	- `new Date()` for a specific date,
	- `Date.now()` to obtain information about the current time,
	- `Date.fromTime()` with a given timestamp or
	- `Date.fromString()` by parsing from a String.

	There are some extra functions available in the `DateTools` class.

	In the context of Haxe dates, a timestamp is defined as the number of
	milliseconds elapsed since 1st January 1970.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="Enum" params="T" file="/home/travis/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see http://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/home/travis/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see http://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<class path="Math" params="" file="/home/travis/haxe/std/js/_std/Math.hx" extern="1"><meta>
	<m n=":keep"/>
	<m n=":directlyUsed"/>
	<m n=":keepInit"/>
</meta></class>
	<class path="String" params="" file="/home/travis/haxe/std/js/_std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.

		Affects the characters `a-z`. Other characters remain unchanged.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.

		Affects the characters `A-Z`. Other characters remain unchanged.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex`. Otherwise the search is
		performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<charCodeAt public="1" get="inline" set="null" line="35">
			<f a="index">
				<x path="Int"/>
				<t path="Null"><x path="Int"/></t>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" get="inline" set="null" line="39">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.
	
	@see http://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/home/travis/haxe/std/js/_std/Std.hx">
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see http://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see http://haxe.org/manual/types-basic-types.html
	@see http://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see http://haxe.org/manual/types-basic-types.html
	@see http://haxe.org/manual/std-math-integer-math.html
	@see http://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Null" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<c path="Null.T"/>
		<haxe_doc>`Null` can be useful in two cases. In order to document some methods
	that accept or can return a `null` value, or for the Flash compiler and AS3
	generator to distinguish between base values that can be `null` and others that
	can't.

	@see http://haxe.org/manual/types-nullability.html</haxe_doc>
	</typedef>
	<abstract path="Bool" params="" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see http://haxe.org/manual/types-bool.html
	@see http://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see http://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see http://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see http://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/home/travis/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see http://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="Vscode" params="" file="src/Vscode.hx" extern="1">
		<version public="1" set="null" static="1">
			<c path="String"/>
			<haxe_doc>* The version of the editor.</haxe_doc>
		</version>
		<env public="1" set="null" static="1">
			<c path="_Vscode.Env"/>
			<haxe_doc>* Namespace describing the environment the editor runs in.</haxe_doc>
		</env>
		<commands public="1" set="null" static="1">
			<c path="_Vscode.Commands"/>
			<haxe_doc><![CDATA[* Namespace for dealing with commands. In short, a command is a function with a
	* unique identifier. The function is sometimes also called _command handler_.
	*
	* Commands can be added to the editor using the [registerCommand](#commands.registerCommand)
	* and [registerTextEditorCommand](#commands.registerTextEditorCommand) functions. Commands
	* can be executed [manually](#commands.executeCommand) or from a UI gesture. Those are:
	*
	* * palette - Use the `commands`-section in `package.json` to make a command show in
	* the [command palette](https://code.visualstudio.com/docs/editor/codebasics#_command-palette).
	* * keybinding - Use the `keybindings`-section in `package.json` to enable
	* [keybindings](https://code.visualstudio.com/docs/customization/keybindings#_customizing-shortcuts)
	* for your extension.
	*
	* Commands from other extensions and from the editor itself are accessible to an extension. However,
	* when invoking an editor command not all argument types are supported.
	*
	* This is a sample that registers a command handler and adds an entry for that command to the palette. First
	* register a command handler with the identfier `extension.sayHello`.
	* ```javascript
	* commands.registerCommand('extension.sayHello', () => {
	* 		window.showInformationMessage('Hello World!');
	* });
	* ```
	* Second, bind the command identfier to a title under which it will show in the palette (`package.json`).
	* ```json
	* {
	* "contributes": {
	* 		"commands": [{
	* 		"command": "extension.sayHello",
	* 		"title": "Hello World"
	* 	}]
	* }
	* ```]]></haxe_doc>
		</commands>
		<window public="1" set="null" static="1">
			<c path="_Vscode.Window"/>
			<haxe_doc>* Namespace for dealing with the current window of the editor. That is visible
	* and active editors, as well as, UI elements to show messages, selections, and
	* asking for user input.</haxe_doc>
		</window>
		<workspace public="1" set="null" static="1">
			<c path="_Vscode.Workspace"/>
			<haxe_doc>* Namespace for dealing with the current workspace. A workspace is the representation
	* of the folder that has been opened. There is no workspace when just a file but not a
	* folder has been opened.
	*
	* The workspace offers support for [listening](#workspace.createFileSystemWatcher) to fs
	* events and for [finding](#workspace.findFiles) files. Both perform well and run _outside_
	* the editor-process so that they should be always used instead of nodejs-equivalents.</haxe_doc>
		</workspace>
		<languages public="1" set="null" static="1">
			<c path="_Vscode.Languages"/>
			<haxe_doc><![CDATA[* Namespace for participating in language-specific editor [features](https://code.visualstudio.com/docs/editor/editingevolved),
	 * like IntelliSense, code actions, diagnostics etc.
	 *
	 * Many programming languages exist and there is huge variety in syntaxes, semantics, and paradigms. Despite that, features
	 * like automatic word-completion, code navigation, or code checking have become popular across different tools for different
	 * programming languages.
	 *
	 * The editor provides an API that makes it simple to provide such common features by having all UI and actions already in place and
	 * by allowing you to participate by providing data only. For instance, to contribute a hover all you have to do is provide a function
	 * that can be called with a [TextDocument](#TextDocument) and a [Position](#Position) returning hover info. The rest, like tracking the
	 * mouse, positioning the hover, keeping the hover stable etc. is taken care of by the editor.
	 *
	 * ```javascript
	 * languages.registerHoverProvider('javascript', {
	 * 		provideHover(document, position, token) {
	 * 			return new Hover('I am a hover!');
	 * 		}
	 * });
	 * ```
	 *
	 * Registration is done using a [document selector](#DocumentSelector) which is either a language id, like `javascript` or
	 * a more complex [filter](#DocumentFilter) like `{ language: 'typescript', scheme: 'file' }`. Matching a document against such
	 * a selector will result in a [score](#languages.match) that is used to determine if and how a provider shall be used. When
	 * scores are equal the provider that came last wins. For features that allow full arity, like [hover](#languages.registerHoverProvider),
	 * the score is only checked to be `>0`, for other features, like [IntelliSense](#languages.registerCompletionItemProvider) the
	 * score is used for determining the order in which providers are asked to participate.]]></haxe_doc>
		</languages>
		<extensions public="1" set="null" static="1">
			<c path="_Vscode.Extensions"/>
			<haxe_doc>* Namespace for dealing with installed extensions. Extensions are represented
	 * by an [extension](#Extension)-interface which allows to reflect on them.
	 *
	 * Extension writers can provide APIs to other extensions by returning their API public
	 * surface from the `activate`-call.
	 *
	 * ```javascript
	 * export function activate(context: vscode.ExtensionContext) {
	 * 		let api = {
	 * 			sum(a, b) {
	 * 				return a + b;
	 * 			},
	 * 			mul(a, b) {
	 * 				return a * b;
	 * 			}
	 * 		};
	 * 		// 'export' public api-surface
	 *		return api;
	* }
	* ```
	* When depending on the API of another extension add an `extensionDependency`-entry
	* to `package.json`, and use the [getExtension](#extensions.getExtension)-function
	* and the [exports](#Extension.exports)-property, like below:
	*
	* ```javascript
	* let mathExt = extensions.getExtension('genius.math');
	* let importedApi = mathExt.exports;
	*
	* console.log(importedApi.mul(42, 1));
	* ```</haxe_doc>
		</extensions>
		<meta><m n=":jsRequire"><e>"vscode"</e></m></meta>
	</class>
	<class path="_Vscode.Env" params="" file="src/Vscode.hx" private="1" module="Vscode" extern="1">
		<appName public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The application name of the editor, like 'VS Code'.
	 *
	 * @readonly</haxe_doc>
		</appName>
		<language public="1" set="null">
			<c path="String"/>
			<haxe_doc>* Represents the preferred user-language, like `de-CH`, `fr`, or `en-US`.
	 *
	 * @readonly</haxe_doc>
		</language>
		<machineId public="1" set="null">
			<c path="String"/>
			<haxe_doc>* A unique identifier for the computer.
	 *
	 * @readonly</haxe_doc>
		</machineId>
		<sessionId public="1" set="null">
			<c path="String"/>
			<haxe_doc>* A unique identifier for the current session.
	 * Changes each time the editor is started.
	 *
	 * @readonly</haxe_doc>
		</sessionId>
	</class>
	<class path="_Vscode.Commands" params="" file="src/Vscode.hx" private="1" module="Vscode" extern="1">
		<registerCommand public="1" set="method">
			<f a="command:callback:?thisArg">
				<c path="String"/>
				<x path="haxe.Function"/>
				<x path="Any"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Registers a command that can be invoked via a keyboard shortcut,
	 * a menu item, an action, or directly.
	 *
	 * Registering a command with an existing command identifier twice
	 * will cause an error.
	 *
	 * @param command A unique identifier for the command.
	 * @param callback A command handler function.
	 * @param thisArg The `this` context used when invoking the handler function.
	 * @return Disposable which unregisters this command on disposal.</haxe_doc>
		</registerCommand>
		<registerTextEditorCommand public="1" set="method">
			<f a="command:callback:?thisArg">
				<c path="String"/>
				<f a=":">
					<t path="vscode.TextEditor"/>
					<t path="vscode.TextEditorEdit"/>
					<x path="Void"/>
				</f>
				<x path="Any"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Registers a text editor command that can be invoked via a keyboard shortcut,
	 * a menu item, an action, or directly.
	 *
	 * Text editor commands are different from ordinary [commands](#commands.registerCommand) as
	 * they only execute when there is an active editor when the command is called. Also, the
	 * command handler of an editor command has access to the active editor and to an
	 * [edit](#TextEditorEdit)-builder.
	 *
	 * @param command A unique identifier for the command.
	 * @param callback A command handler function with access to an [editor](#TextEditor) and an [edit](#TextEditorEdit).
	 * @param thisArg The `this` context used when invoking the handler function.
	 * @return Disposable which unregisters this command on disposal.</haxe_doc>
		</registerTextEditorCommand>
		<executeCommand public="1" params="T" set="method">
			<f a="command:rest">
				<c path="String"/>
				<x path="haxe.extern.Rest"><x path="Any"/></x>
				<t path="js.Thenable"><c path="executeCommand.T"/></t>
			</f>
			<haxe_doc>* Executes the command denoted by the given command identifier.
	 *
	 * When executing an editor command not all types are allowed to
	 * be passed as arguments. Allowed are the primitive types `string`, `boolean`,
	 * `number`, `undefined`, and `null`, as well as classes defined in this API.
	 * There are no restrictions when executing commands that have been contributed
	 * by extensions.
	 *
	 * @param command Identifier of the command to execute.
	 * @param rest Parameters passed to the command function.
	 * @return A thenable that resolves to the returned value of the given command. `undefined` when
	 * the command handler function doesn't return anything.</haxe_doc>
		</executeCommand>
		<getCommands public="1" set="method">
			<f a="?filterInternal">
				<x path="Bool"/>
				<t path="js.Thenable"><c path="Array"><c path="String"/></c></t>
			</f>
			<haxe_doc>* Retrieve the list of all available commands. Commands starting an underscore are
	 * treated as internal commands.
	 *
	 * @param filterInternal Set `true` to not see internal commands (starting with an underscore)
	 * @return Thenable that resolves to a list of command ids.</haxe_doc>
		</getCommands>
	</class>
	<class path="_Vscode.Window" params="" file="src/Vscode.hx" private="1" module="Vscode" extern="1">
		<activeTextEditor public="1">
			<t path="vscode.TextEditor"/>
			<haxe_doc>* The currently active editor or `undefined`. The active editor is the one
	 * that currently has focus or, when none has focus, the one that has changed
	 * input most recently.</haxe_doc>
		</activeTextEditor>
		<visibleTextEditors public="1">
			<c path="Array"><t path="vscode.TextEditor"/></c>
			<haxe_doc>* The currently visible editors or an empty array.</haxe_doc>
		</visibleTextEditors>
		<onDidChangeActiveTextEditor public="1" set="null">
			<t path="vscode.Event"><t path="vscode.TextEditor"/></t>
			<haxe_doc>* An [event](#Event) which fires when the [active editor](#window.activeTextEditor)
	 * has changed. *Note* that the event also fires when the active editor changes
	 * to `undefined`.</haxe_doc>
		</onDidChangeActiveTextEditor>
		<onDidChangeTextEditorSelection public="1" set="null">
			<t path="vscode.Event"><t path="vscode.TextEditorSelectionChangeEvent"/></t>
			<haxe_doc>* An [event](#Event) which fires when the selection in an editor has changed.</haxe_doc>
		</onDidChangeTextEditorSelection>
		<onDidChangeTextEditorOptions public="1" set="null">
			<t path="vscode.Event"><t path="vscode.TextEditorOptionsChangeEvent"/></t>
			<haxe_doc>* An [event](#Event) which fires when the options of an editor have changed.</haxe_doc>
		</onDidChangeTextEditorOptions>
		<onDidChangeTextEditorViewColumn public="1" set="null">
			<t path="vscode.Event"><t path="vscode.TextEditorViewColumnChangeEvent"/></t>
			<haxe_doc>* An [event](#Event) which fires when the view column of an editor has changed.</haxe_doc>
		</onDidChangeTextEditorViewColumn>
		<showTextDocument public="1" set="method">
			<f a="document:?column:?preserveFocus">
				<t path="vscode.TextDocument"/>
				<x path="vscode.ViewColumn"/>
				<x path="Bool"/>
				<t path="js.Thenable"><t path="vscode.TextEditor"/></t>
			</f>
			<haxe_doc>* Show the given document in a text editor. A [column](#ViewColumn) can be provided
	 * to control where the editor is being shown. Might change the [active editor](#window.activeTextEditor).
	 *
	 * @param document A text document to be shown.
	 * @param column A view column in which the editor should be shown. The default is the [one](#ViewColumn.One), other values
	 * are adjusted to be __Min(column, columnCount + 1)__.
	 * @param preserveFocus When `true` the editor will not take focus.
	 * @return A promise that resolves to an [editor](#TextEditor).</haxe_doc>
		</showTextDocument>
		<createTextEditorDecorationType public="1" set="method">
			<f a="options">
				<t path="vscode.DecorationRenderOptions"/>
				<t path="vscode.TextEditorDecorationType"/>
			</f>
			<haxe_doc>* Create a TextEditorDecorationType that can be used to add decorations to text editors.
	 *
	 * @param options Rendering options for the decoration type.
	 * @return A new decoration type instance.</haxe_doc>
		</createTextEditorDecorationType>
		<showInformationMessage public="1" params="T" set="method">
			<f a="message:items">
				<c path="String"/>
				<x path="haxe.extern.Rest"><c path="showInformationMessage.T"/></x>
				<t path="js.Thenable"><c path="showInformationMessage.T"/></t>
			</f>
			<haxe_doc>* Show an information message.
	 *
	 * @see [showInformationMessage](#window.showInformationMessage)
	 *
	 * @param message The message to show.
	 * @param items A set of items that will be rendered as actions in the message.
	 * @return A thenable that resolves to the selected item or `undefined` when being dismissed.</haxe_doc>
			<overloads><showInformationMessage public="1" set="method">
	<f a="message:items">
		<c path="String"/>
		<x path="haxe.extern.Rest"><c path="String"/></x>
		<t path="js.Thenable"><c path="String"/></t>
	</f>
	<haxe_doc>* Show an information message.
	 *
	 * @see [showInformationMessage](#window.showInformationMessage)
	 *
	 * @param message The message to show.
	 * @param items A set of items that will be rendered as actions in the message.
	 * @return A thenable that resolves to the selected item or `undefined` when being dismissed.</haxe_doc>
</showInformationMessage></overloads>
		</showInformationMessage>
		<showWarningMessage public="1" params="T" set="method">
			<f a="message:items">
				<c path="String"/>
				<x path="haxe.extern.Rest"><c path="showWarningMessage.T"/></x>
				<t path="js.Thenable"><c path="showWarningMessage.T"/></t>
			</f>
			<haxe_doc>* Show a warning message.
	 *
	 * @see [showInformationMessage](#window.showInformationMessage)
	 *
	 * @param message The message to show.
	 * @param items A set of items that will be rendered as actions in the message.
	 * @return A thenable that resolves to the selected item or `undefined` when being dismissed.</haxe_doc>
			<overloads><showWarningMessage public="1" set="method">
	<f a="message:items">
		<c path="String"/>
		<x path="haxe.extern.Rest"><c path="String"/></x>
		<t path="js.Thenable"><c path="String"/></t>
	</f>
	<haxe_doc>* Show a warning message.
	 *
	 * @see [showInformationMessage](#window.showInformationMessage)
	 *
	 * @param message The message to show.
	 * @param items A set of items that will be rendered as actions in the message.
	 * @return A thenable that resolves to the selected item or `undefined` when being dismissed.</haxe_doc>
</showWarningMessage></overloads>
		</showWarningMessage>
		<showErrorMessage public="1" params="T" set="method">
			<f a="message:items">
				<c path="String"/>
				<x path="haxe.extern.Rest"><c path="showErrorMessage.T"/></x>
				<t path="js.Thenable"><c path="showErrorMessage.T"/></t>
			</f>
			<haxe_doc>* Show an error message.
	 *
	 * @see [showInformationMessage](#window.showInformationMessage)
	 *
	 * @param message The message to show.
	 * @param items A set of items that will be rendered as actions in the message.
	 * @return A thenable that resolves to the selected item or `undefined` when being dismissed.</haxe_doc>
			<overloads><showErrorMessage public="1" set="method">
	<f a="message:items">
		<c path="String"/>
		<x path="haxe.extern.Rest"><c path="String"/></x>
		<t path="js.Thenable"><c path="String"/></t>
	</f>
	<haxe_doc>* Show an error message.
	 *
	 * @see [showInformationMessage](#window.showInformationMessage)
	 *
	 * @param message The message to show.
	 * @param items A set of items that will be rendered as actions in the message.
	 * @return A thenable that resolves to the selected item or `undefined` when being dismissed.</haxe_doc>
</showErrorMessage></overloads>
		</showErrorMessage>
		<showQuickPick public="1" params="T" set="method">
			<f a="items:?options">
				<x path="haxe.extern.EitherType">
					<c path="Array"><c path="showQuickPick.T"/></c>
					<t path="js.Thenable"><c path="Array"><c path="showQuickPick.T"/></c></t>
				</x>
				<t path="vscode.QuickPickOptions"/>
				<t path="js.Thenable"><c path="showQuickPick.T"/></t>
			</f>
			<haxe_doc>* Shows a selection list.
	 *
	 * @param items An array of strings, or a promise that resolves to an array of strings.
	 * @param options Configures the behavior of the selection list.
	 * @return A promise that resolves to the selection or undefined.</haxe_doc>
			<overloads><showQuickPick public="1" set="method">
	<f a="items:?options">
		<x path="haxe.extern.EitherType">
			<c path="Array"><c path="String"/></c>
			<t path="js.Thenable"><c path="Array"><c path="String"/></c></t>
		</x>
		<t path="vscode.QuickPickOptions"/>
		<t path="js.Thenable"><c path="String"/></t>
	</f>
	<haxe_doc>* Shows a selection list.
	 *
	 * @param items An array of strings, or a promise that resolves to an array of strings.
	 * @param options Configures the behavior of the selection list.
	 * @return A promise that resolves to the selection or undefined.</haxe_doc>
</showQuickPick></overloads>
		</showQuickPick>
		<showInputBox public="1" set="method">
			<f a="?options">
				<t path="vscode.InputBoxOptions"/>
				<t path="js.Thenable"><c path="String"/></t>
			</f>
			<haxe_doc>* Opens an input box to ask the user for input.
	 *
	 * The returned value will be undefined if the input box was canceled (e.g. pressing ESC). Otherwise the
	 * returned value will be the string typed by the user or an empty string if the user did not type
	 * anything but dismissed the input box with OK.
	 *
	 * @param options Configures the behavior of the input box.
	 * @return A promise that resolves to a string the user provided or to `undefined` in case of dismissal.</haxe_doc>
		</showInputBox>
		<createOutputChannel public="1" set="method">
			<f a="name">
				<c path="String"/>
				<t path="vscode.OutputChannel"/>
			</f>
			<haxe_doc>* Create a new [output channel](#OutputChannel) with the given name.
	 *
	 * @param name Human-readable string which will be used to represent the channel in the UI.</haxe_doc>
		</createOutputChannel>
		<setStatusBarMessage public="1" set="method">
			<f a="text">
				<c path="String"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Set a message to the status bar. This is a short hand for the more powerful
	 * status bar [items](#window.createStatusBarItem).
	 *
	 * @param text The message to show, support icon subtitution as in status bar [items](#StatusBarItem.text).
	 * @param hideAfterTimeout Timeout in milliseconds after which the message will be disposed.
	 * @param hideWhenDone Thenable on which completion (resolve or reject) the message will be disposed.
	 * @return A disposable which hides the status bar message.</haxe_doc>
			<overloads>
				<setStatusBarMessage public="1" set="method">
					<f a="text:hideAfterTimeout">
						<c path="String"/>
						<x path="Float"/>
						<c path="vscode.Disposable"/>
					</f>
					<haxe_doc>* Set a message to the status bar. This is a short hand for the more powerful
	 * status bar [items](#window.createStatusBarItem).
	 *
	 * @param text The message to show, support icon subtitution as in status bar [items](#StatusBarItem.text).
	 * @param hideAfterTimeout Timeout in milliseconds after which the message will be disposed.
	 * @param hideWhenDone Thenable on which completion (resolve or reject) the message will be disposed.
	 * @return A disposable which hides the status bar message.</haxe_doc>
				</setStatusBarMessage>
				<setStatusBarMessage public="1" set="method">
					<f a="text:hideWhenDone">
						<c path="String"/>
						<t path="js.Thenable"><x path="Any"/></t>
						<c path="vscode.Disposable"/>
					</f>
					<haxe_doc>* Set a message to the status bar. This is a short hand for the more powerful
	 * status bar [items](#window.createStatusBarItem).
	 *
	 * @param text The message to show, support icon subtitution as in status bar [items](#StatusBarItem.text).
	 * @param hideAfterTimeout Timeout in milliseconds after which the message will be disposed.
	 * @param hideWhenDone Thenable on which completion (resolve or reject) the message will be disposed.
	 * @return A disposable which hides the status bar message.</haxe_doc>
				</setStatusBarMessage>
			</overloads>
		</setStatusBarMessage>
		<createStatusBarItem public="1" set="method">
			<f a="?alignment:?priority">
				<x path="vscode.StatusBarAlignment"/>
				<x path="Float"/>
				<t path="vscode.StatusBarItem"/>
			</f>
			<haxe_doc>* Creates a status bar [item](#StatusBarItem).
	 *
	 * @param alignment The alignment of the item.
	 * @param priority The priority of the item. Higher values mean the item should be shown more to the left.
	 * @return A new status bar item.</haxe_doc>
		</createStatusBarItem>
	</class>
	<class path="_Vscode.Extensions" params="" file="src/Vscode.hx" private="1" module="Vscode" extern="1">
		<getExtension public="1" params="T" set="method">
			<f a="extensionId">
				<c path="String"/>
				<t path="vscode.Extension"><c path="getExtension.T"/></t>
			</f>
			<haxe_doc>* Get an extension by its full identifier in the form of: `publisher.name`.
	 *
	 * @param extensionId An extension identifier.
	 * @return An extension or `undefined`.</haxe_doc>
		</getExtension>
		<all public="1" set="null">
			<c path="Array"><t path="vscode.Extension"><x path="Any"/></t></c>
			<haxe_doc>* All extensions currently known to the system.</haxe_doc>
		</all>
	</class>
	<class path="_Vscode.Languages" params="" file="src/Vscode.hx" private="1" module="Vscode" extern="1">
		<getLanguages public="1" set="method">
			<f a=""><t path="js.Thenable"><c path="Array"><c path="String"/></c></t></f>
			<haxe_doc>* Return the identifiers of all known languages.
	 * @return Promise resolving to an array of identifier strings.</haxe_doc>
		</getLanguages>
		<match public="1" set="method">
			<f a="selector:document">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.TextDocument"/>
				<x path="Float"/>
			</f>
			<haxe_doc><![CDATA[* Compute the match between a document [selector](#DocumentSelector) and a document. Values
	 * greater than zero mean the selector matches the document. The more individual matches a selector
	 * and a document have, the higher the score is. These are the abstract rules given a `selector`:
	 *
	 * ```
	 * (1) When selector is an array, return the maximum individual result.
	 * (2) When selector is a string match that against the [languageId](#TextDocument.languageId).
	 * 	(2.1) When both are equal score is `10`,
	 * 	(2.2) When the selector is `*` score is `5`,
	 * 	(2.3) Else score is `0`.
	 * (3) When selector is a [filter](#DocumentFilter) return the maximum individual score given that each score is `>0`.
	 *	(3.1) When [language](#DocumentFilter.language) is set apply rules from #2, when `0` the total score is `0`.
		*	(3.2) When [scheme](#DocumentFilter.scheme) is set and equals the [uri](#TextDocument.uri)-scheme score with `10`, else the total score is `0`.
		*	(3.3) When [pattern](#DocumentFilter.pattern) is set
		* 		(3.3.1) pattern equals the [uri](#TextDocument.uri)-fsPath score with `10`,
		*		(3.3.1) if the pattern matches as glob-pattern score with `5`,
		*		(3.3.1) the total score is `0`
		* ```
		*
		* @param selector A document selector.
		* @param document A text document.
		* @return A number `>0` when the selector matches and `0` when the selector does not match.]]></haxe_doc>
		</match>
		<createDiagnosticCollection public="1" set="method">
			<f a="?name">
				<c path="String"/>
				<t path="vscode.DiagnosticCollection"/>
			</f>
			<haxe_doc>* Create a diagnostics collection.
	 *
	 * @param name The [name](#DiagnosticCollection.name) of the collection.
	 * @return A new diagnostic collection.</haxe_doc>
		</createDiagnosticCollection>
		<registerCompletionItemProvider public="1" set="method">
			<f a="selector:provider:triggerCharacters">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.CompletionItemProvider"/>
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a completion provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are sorted
	 * by their [score](#languages.match) and groups of equal score are sequentially asked for
	 * completion items. The process stops when one or many providers of a group return a
	 * result. A failing provider (rejected promise or exception) will not fail the whole
	 * operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A completion provider.
	 * @param triggerCharacters Trigger completion when the user types one of the characters, like `.` or `:`.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerCompletionItemProvider>
		<registerCodeActionsProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.CodeActionProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a code action provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are asked in
	 * parallel and the results are merged. A failing provider (rejected promise or exception) will
	 * not cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A code action provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerCodeActionsProvider>
		<registerCodeLensProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.CodeLensProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a code lens provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are asked in
	 * parallel and the results are merged. A failing provider (rejected promise or exception) will
	 * not cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A code lens provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerCodeLensProvider>
		<registerDefinitionProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.DefinitionProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a definition provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are asked in
	 * parallel and the results are merged. A failing provider (rejected promise or exception) will
	 * not cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A definition provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerDefinitionProvider>
		<registerHoverProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.HoverProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a hover provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are asked in
	 * parallel and the results are merged. A failing provider (rejected promise or exception) will
	 * not cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A hover provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerHoverProvider>
		<registerDocumentHighlightProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.DocumentHighlightProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a document highlight provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are sorted
	 * by their [score](#languages.match) and groups sequentially asked for document highlights.
	 * The process stops when a provider returns a `non-falsy` or `non-failure` result.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A document highlight provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerDocumentHighlightProvider>
		<registerDocumentSymbolProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.DocumentSymbolProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a document symbol provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are asked in
	 * parallel and the results are merged. A failing provider (rejected promise or exception) will
	 * not cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A document symbol provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerDocumentSymbolProvider>
		<registerWorkspaceSymbolProvider public="1" set="method">
			<f a="provider">
				<t path="vscode.WorkspaceSymbolProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a workspace symbol provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are asked in
	 * parallel and the results are merged. A failing provider (rejected promise or exception) will
	 * not cause a failure of the whole operation.
	 *
	 * @param provider A workspace symbol provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerWorkspaceSymbolProvider>
		<registerReferenceProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.ReferenceProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a reference provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are asked in
	 * parallel and the results are merged. A failing provider (rejected promise or exception) will
	 * not cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A reference provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerReferenceProvider>
		<registerRenameProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.RenameProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a rename provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are sorted
	 * by their [score](#languages.match) and the best-matching provider is used. Failure
	 * of the selected provider will cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A rename provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerRenameProvider>
		<registerDocumentFormattingEditProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.DocumentFormattingEditProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a formatting provider for a document.
	 *
	 * Multiple providers can be registered for a language. In that case providers are sorted
	 * by their [score](#languages.match) and the best-matching provider is used. Failure
	 * of the selected provider will cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A document formatting edit provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerDocumentFormattingEditProvider>
		<registerDocumentRangeFormattingEditProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.DocumentRangeFormattingEditProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a formatting provider for a document range.
	 *
	 * Multiple providers can be registered for a language. In that case providers are sorted
	 * by their [score](#languages.match) and the best-matching provider is used. Failure
	 * of the selected provider will cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A document range formatting edit provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerDocumentRangeFormattingEditProvider>
		<registerOnTypeFormattingEditProvider public="1" set="method">
			<f a="selector:provider:firstTriggerCharacter:moreTriggerCharacter">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.OnTypeFormattingEditProvider"/>
				<c path="String"/>
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a formatting provider that works on type. The provider is active when the user enables the setting `editor.formatOnType`.
	 *
	 * Multiple providers can be registered for a language. In that case providers are sorted
	 * by their [score](#languages.match) and the best-matching provider is used. Failure
	 * of the selected provider will cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider An on type formatting edit provider.
	 * @param firstTriggerCharacter A character on which formatting should be triggered, like `}`.
	 * @param moreTriggerCharacter More trigger characters.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerOnTypeFormattingEditProvider>
		<registerSignatureHelpProvider public="1" set="method">
			<f a="selector:provider:triggerCharacters">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.SignatureHelpProvider"/>
				<x path="haxe.extern.Rest"><c path="String"/></x>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a signature help provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are sorted
	 * by their [score](#languages.match) and the best-matching provider is used. Failure
	 * of the selected provider will cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A signature help provider.
	 * @param triggerCharacters Trigger signature help when the user types one of the characters, like `,` or `(`.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerSignatureHelpProvider>
		<registerDocumentLinkProvider public="1" set="method">
			<f a="selector:provider">
				<t path="vscode.DocumentSelector"/>
				<t path="vscode.DocumentLinkProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a document link provider.
	 *
	 * Multiple providers can be registered for a language. In that case providers are asked in
	 * parallel and the results are merged. A failing provider (rejected promise or exception) will
	 * not cause a failure of the whole operation.
	 *
	 * @param selector A selector that defines the documents this provider is applicable to.
	 * @param provider A document link provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerDocumentLinkProvider>
		<setLanguageConfiguration public="1" set="method">
			<f a="language:configuration">
				<c path="String"/>
				<t path="vscode.LanguageConfiguration"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Set a [language configuration](#LanguageConfiguration) for a language.
	 *
	 * @param language A language identifier like `typescript`.
	 * @param configuration Language configuration.
	 * @return A [disposable](#Disposable) that unsets this configuration.</haxe_doc>
		</setLanguageConfiguration>
	</class>
	<class path="_Vscode.Workspace" params="" file="src/Vscode.hx" private="1" module="Vscode" extern="1">
		<createFileSystemWatcher public="1" set="method">
			<f a="globPattern:?ignoreCreateEvents:?ignoreChangeEvents:?ignoreDeleteEvents">
				<c path="String"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<x path="Bool"/>
				<c path="vscode.FileSystemWatcher"/>
			</f>
			<haxe_doc>* Creates a file system watcher.
	 *
	 * A glob pattern that filters the file events must be provided. Optionally, flags to ignore certain
	 * kinds of events can be provided. To stop listening to events the watcher must be disposed.
	 *
	 * @param globPattern A glob pattern that is applied to the names of created, changed, and deleted files.
	 * @param ignoreCreateEvents Ignore when files have been created.
	 * @param ignoreChangeEvents Ignore when files have been changed.
	 * @param ignoreDeleteEvents Ignore when files have been deleted.
	 * @return A new file system watcher instance.</haxe_doc>
		</createFileSystemWatcher>
		<rootPath public="1" set="null">
			<c path="String"/>
			<haxe_doc>* The folder that is open in VS Code. `undefined` when no folder
	 * has been opened.
	 *
	 * @readonly</haxe_doc>
		</rootPath>
		<asRelativePath public="1" set="method">
			<f a="pathOrUri">
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<c path="vscode.Uri"/>
				</x>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns a path that is relative to the workspace root.
	 *
	 * When there is no [workspace root](#workspace.rootPath) or when the path
	 * is not a child of that folder, the input is returned.
	 *
	 * @param pathOrUri A path or uri. When a uri is given its [fsPath](#Uri.fsPath) is used.
	 * @return A path relative to the root or the input.</haxe_doc>
		</asRelativePath>
		<findFiles public="1" set="method">
			<f a="include:exclude:?maxResults:?token">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<t path="vscode.CancellationToken"/>
				<t path="js.Thenable"><c path="Array"><c path="vscode.Uri"/></c></t>
			</f>
			<haxe_doc>* Find files in the workspace.
	 *
	 * @sample `findFiles('***.js', '**node_modules**', 10)`
	 * @param include A glob pattern that defines the files to search for.
	 * @param exclude A glob pattern that defines files and folders to exclude.
	 * @param maxResults An upper-bound for the result.
	 * @param token A token that can be used to signal cancellation to the underlying search engine.
	 * @return A thenable that resolves to an array of resource identifiers.</haxe_doc>
		</findFiles>
		<saveAll public="1" set="method">
			<f a="?includeUntitled">
				<x path="Bool"/>
				<t path="js.Thenable"><x path="Bool"/></t>
			</f>
			<haxe_doc>* Save all dirty files.
	 *
	 * @param includeUntitled Also save files that have been created during this session.
	 * @return A thenable that resolves when the files have been saved.</haxe_doc>
		</saveAll>
		<applyEdit public="1" set="method">
			<f a="edit">
				<c path="vscode.WorkspaceEdit"/>
				<t path="js.Thenable"><x path="Bool"/></t>
			</f>
			<haxe_doc>* Make changes to one or many resources as defined by the given
	 * [workspace edit](#WorkspaceEdit).
	 *
	 * When applying a workspace edit, the editor implements an 'all-or-nothing'-strategy,
	 * that means failure to load one document or make changes to one document will cause
	 * the edit to be rejected.
	 *
	 * @param edit A workspace edit.
	 * @return A thenable that resolves when the edit could be applied.</haxe_doc>
		</applyEdit>
		<textDocuments public="1" set="null">
			<c path="Array"><t path="vscode.TextDocument"/></c>
			<haxe_doc>* All text documents currently known to the system.
	 *
	 * @readonly</haxe_doc>
		</textDocuments>
		<openTextDocument public="1" set="method">
			<f a="uri">
				<c path="vscode.Uri"/>
				<t path="js.Thenable"><t path="vscode.TextDocument"/></t>
			</f>
			<haxe_doc>* Opens the denoted document from disk. Will return early if the
	 * document is already open, otherwise the document is loaded and the
	 * [open document](#workspace.onDidOpenTextDocument)-event fires.
	 * The document to open is denoted by the [uri](#Uri). Two schemes are supported:
	 *
	 * file: A file on disk, will be rejected if the file does not exist or cannot be loaded, e.g. `file:///Users/frodo/r.ini`.
	 * untitled: A new file that should be saved on disk, e.g. `untitled:c:\frodo\new.js`. The language will be derived from the file name.
	 *
	 * Uris with other schemes will make this method return a rejected promise.
	 *
	 * @param uri Identifies the resource to open.
	 * @return A promise that resolves to a [document](#TextDocument).</haxe_doc>
			<overloads><openTextDocument public="1" set="method">
	<f a="fileName">
		<c path="String"/>
		<t path="js.Thenable"><t path="vscode.TextDocument"/></t>
	</f>
	<haxe_doc>* Opens the denoted document from disk. Will return early if the
	 * document is already open, otherwise the document is loaded and the
	 * [open document](#workspace.onDidOpenTextDocument)-event fires.
	 * The document to open is denoted by the [uri](#Uri). Two schemes are supported:
	 *
	 * file: A file on disk, will be rejected if the file does not exist or cannot be loaded, e.g. `file:///Users/frodo/r.ini`.
	 * untitled: A new file that should be saved on disk, e.g. `untitled:c:\frodo\new.js`. The language will be derived from the file name.
	 *
	 * Uris with other schemes will make this method return a rejected promise.
	 *
	 * @param uri Identifies the resource to open.
	 * @return A promise that resolves to a [document](#TextDocument).</haxe_doc>
</openTextDocument></overloads>
		</openTextDocument>
		<registerTextDocumentContentProvider public="1" set="method">
			<f a="scheme:provider">
				<c path="String"/>
				<t path="vscode.TextDocumentContentProvider"/>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Register a text document content provider.
	 *
	 * Only one provider can be registered per scheme.
	 *
	 * @param scheme The uri-scheme to register for.
	 * @param provider A content provider.
	 * @return A [disposable](#Disposable) that unregisters this provider when being disposed.</haxe_doc>
		</registerTextDocumentContentProvider>
		<onDidOpenTextDocument public="1" set="null">
			<t path="vscode.Event"><t path="vscode.TextDocument"/></t>
			<haxe_doc>* An event that is emitted when a [text document](#TextDocument) is opened.</haxe_doc>
		</onDidOpenTextDocument>
		<onDidCloseTextDocument public="1" set="null">
			<t path="vscode.Event"><t path="vscode.TextDocument"/></t>
			<haxe_doc>* An event that is emitted when a [text document](#TextDocument) is disposed.</haxe_doc>
		</onDidCloseTextDocument>
		<onDidChangeTextDocument public="1" set="null">
			<t path="vscode.Event"><t path="vscode.TextDocumentChangeEvent"/></t>
			<haxe_doc>* An event that is emitted when a [text document](#TextDocument) is changed.</haxe_doc>
		</onDidChangeTextDocument>
		<onDidSaveTextDocument public="1" set="null">
			<t path="vscode.Event"><t path="vscode.TextDocument"/></t>
			<haxe_doc>* An event that is emitted when a [text document](#TextDocument) is saved to disk.</haxe_doc>
		</onDidSaveTextDocument>
		<getConfiguration public="1" set="method">
			<f a="?section">
				<c path="String"/>
				<t path="vscode.WorkspaceConfiguration"/>
			</f>
			<haxe_doc>* Get a configuration object.
	 *
	 * When a section-identifier is provided only that part of the configuration
	 * is returned. Dots in the section-identifier are interpreted as child-access,
	 * like `{ myExt: { setting: { doIt: true }}}` and `getConfiguration('myExt.setting.doIt') === true`.
	 *
	 *
	 * @param section A dot-separated identifier.
	 * @return The full workspace configuration or a subset.</haxe_doc>
		</getConfiguration>
		<onDidChangeConfiguration public="1" set="null">
			<t path="vscode.Event"><x path="Void"/></t>
			<haxe_doc>* An event that is emitted when the [configuration](#WorkspaceConfiguration) changed.</haxe_doc>
		</onDidChangeConfiguration>
	</class>
	<abstract path="haxe.Function" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/home/travis/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which
		* is public and
		* unifies with the type used for type parameter `T`.

	If a type parameter A is assigned to a type parameter B which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/home/travis/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="/home/travis/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="50" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
			pack1.pack2.(...).packN.EnumName
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="63" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="79" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="96" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="108" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an 
  [extension](http://haxe.org/manual/lf-static-extension.html) to the 
  `enum` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/home/travis/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="132" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="143" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="157" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="169" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<match public="1" set="method" static="1">
			<f a="e:pattern">
				<x path="EnumValue"/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Matches enum instance `e` against pattern `pattern`, returning `true` if
		matching succeeded and `false` otherwise.

		Example usage:

		```haxe
		if (e.match(pattern)) {
			// codeIfTrue
		} else {
			// codeIfFalse
		}
		```

		This is equivalent to the following code:

		```haxe
		switch (e) {
			case pattern:
				// codeIfTrue
			case _:
				// codeIfFalse
		}
		```

		This method is implemented in the compiler. This definition exists only
		for documentation.</haxe_doc>
		</match>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an 
  [extension](http://haxe.org/manual/lf-static-extension.html) to the 
  `EnumValue` types.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/home/travis/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<t path="Null"><c path="Array"><d/></c></t>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>PosInfos is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	(..., ?pos:haxe.PosInfos), each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/home/travis/haxe/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.
	
	@see <http://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/home/travis/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.extern.Rest" params="T" file="/home/travis/haxe/std/haxe/extern/Rest.hx">
		<this><c path="Array"><c path="haxe.extern.Rest.T"/></c></this>
		<haxe_doc><![CDATA[A special abstract type that represents "rest" function argument.

	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.
	
	@see <http://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<impl><class path="haxe.extern._Rest.Rest_Impl_" params="" file="/home/travis/haxe/std/haxe/extern/Rest.hx" private="1" module="haxe.extern.Rest"><meta>
	<m n=":keep"/>
	<m n=":final"/>
</meta></class></impl>
	</abstract>
	<class path="js.Error" params="" file="/home/travis/haxe/std/js/Error.hx" extern="1">
		<message public="1"><c path="String"/></message>
		<name public="1"><c path="String"/></name>
		<stack public="1" set="null"><c path="String"/></stack>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"Error"</e></m></meta>
	</class>
	<class path="js.EvalError" params="" file="/home/travis/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"EvalError"</e></m></meta>
	</class>
	<class path="js.RangeError" params="" file="/home/travis/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"RangeError"</e></m></meta>
	</class>
	<class path="js.ReferenceError" params="" file="/home/travis/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"ReferenceError"</e></m></meta>
	</class>
	<class path="js.SyntaxError" params="" file="/home/travis/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"SyntaxError"</e></m></meta>
	</class>
	<class path="js.TypeError" params="" file="/home/travis/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"TypeError"</e></m></meta>
	</class>
	<class path="js.URIError" params="" file="/home/travis/haxe/std/js/Error.hx" module="js.Error" extern="1">
		<extends path="js.Error"/>
		<new public="1" set="method"><f a="?message">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":native"><e>"URIError"</e></m></meta>
	</class>
	<class path="js.Promise" params="T" file="/home/travis/haxe/std/js/Promise.hx" extern="1">
		<resolve public="1" params="T" set="method" static="1">
			<f a="?value">
				<c path="resolve.T"/>
				<c path="js.Promise"><c path="resolve.T"/></c>
			</f>
			<overloads>
				<resolve public="1" params="T" set="method"><f a="promise">
	<c path="js.Promise"><c path="resolve.T"/></c>
	<c path="js.Promise"><c path="resolve.T"/></c>
</f></resolve>
				<resolve public="1" params="T" set="method"><f a="thenable">
	<t path="js.Thenable"><c path="resolve.T"/></t>
	<c path="js.Promise"><c path="resolve.T"/></c>
</f></resolve>
			</overloads>
		</resolve>
		<reject public="1" params="T" set="method" static="1"><f a="?value">
	<d/>
	<c path="js.Promise"><c path="reject.T"/></c>
</f></reject>
		<all public="1" set="method" static="1"><f a="iterable">
	<c path="Array"><d/></c>
	<c path="js.Promise"><c path="Array"><d/></c></c>
</f></all>
		<race public="1" set="method" static="1"><f a="iterable">
	<c path="Array"><d/></c>
	<c path="js.Promise"><d/></c>
</f></race>
		<then public="1" params="TOut" set="method"><f a="fulfillCallback:?rejectCallback">
	<t path="Null"><t path="js.PromiseCallback">
	<c path="js.Promise.T"/>
	<c path="then.TOut"/>
</t></t>
	<x path="haxe.extern.EitherType">
		<f a="">
			<d/>
			<x path="Void"/>
		</f>
		<t path="js.PromiseCallback">
			<d/>
			<c path="then.TOut"/>
		</t>
	</x>
	<c path="js.Promise"><c path="then.TOut"/></c>
</f></then>
		<catchError public="1" params="TOut" set="method">
			<f a="rejectCallback">
				<x path="haxe.extern.EitherType">
					<f a="">
						<d/>
						<x path="Void"/>
					</f>
					<t path="js.PromiseCallback">
						<d/>
						<c path="catchError.TOut"/>
					</t>
				</x>
				<c path="js.Promise"><c path="catchError.TOut"/></c>
			</f>
			<meta><m n=":native"><e>"catch"</e></m></meta>
		</catchError>
		<new public="1" set="method">
			<f a="init">
				<f a=":">
					<f a="">
						<c path="js.Promise.T"/>
						<x path="Void"/>
					</f>
					<f a="">
						<d/>
						<x path="Void"/>
					</f>
					<x path="Void"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc>@throws DOMError</haxe_doc>
		</new>
		<meta><m n=":native"><e>"Promise"</e></m></meta>
	</class>
	<typedef path="js.PromiseCallback" params="T:TOut" file="/home/travis/haxe/std/js/Promise.hx" module="js.Promise"><x path="haxe.extern.EitherType">
	<f a="">
		<c path="js.PromiseCallback.T"/>
		<c path="js.PromiseCallback.TOut"/>
	</f>
	<f a="">
		<c path="js.PromiseCallback.T"/>
		<c path="js.Promise"><c path="js.PromiseCallback.TOut"/></c>
	</f>
</x></typedef>
	<typedef path="js.Thenable" params="T" file="/home/travis/haxe/std/js/Promise.hx" module="js.Promise"><a><then set="method"><f a="resolve:?reject">
	<f a="">
		<c path="js.Thenable.T"/>
		<x path="Void"/>
	</f>
	<f a="">
		<d/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></then></a></typedef>
	<class path="js.RegExp" params="" file="/home/travis/haxe/std/js/RegExp.hx" extern="1">
		<global public="1" set="null"><x path="Bool"/></global>
		<ignoreCase public="1" set="null"><x path="Bool"/></ignoreCase>
		<multiline public="1" set="null"><x path="Bool"/></multiline>
		<source public="1" set="null"><c path="String"/></source>
		<lastIndex public="1"><x path="Int"/></lastIndex>
		<exec public="1" set="method"><f a="str">
	<c path="String"/>
	<t path="Null"><c path="js.RegExpMatch"/></t>
</f></exec>
		<test public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Bool"/>
</f></test>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<new public="1" set="method"><f a="pattern:?flags">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>Native JavaScript regular expressions.

    For cross-platform regular expressions, use Haxe `EReg` class or 
    [regexp literals](http://haxe.org/manual/std-regex.html).</haxe_doc>
		<meta><m n=":native"><e>"RegExp"</e></m></meta>
	</class>
	<class path="js.RegExpMatch" params="" file="/home/travis/haxe/std/js/RegExp.hx" module="js.RegExp" extern="1">
		<extends path="Array"><c path="String"/></extends>
		<index public="1"><x path="Int"/></index>
		<input public="1"><c path="String"/></input>
	</class>
	<typedef path="vscode.CancellationToken" params="" file="src/vscode/CancellationToken.hx">
		<a>
			<onCancellationRequested>
				<t path="vscode.Event"><x path="Any"/></t>
				<haxe_doc>* An [event](#Event) which fires upon cancellation.</haxe_doc>
			</onCancellationRequested>
			<isCancellationRequested>
				<x path="Bool"/>
				<haxe_doc>* Is `true` when the token has been cancelled, `false` otherwise.</haxe_doc>
			</isCancellationRequested>
		</a>
		<haxe_doc>* A cancellation token is passed to an asynchronous or long running
 * operation to request cancellation, like cancelling a request
 * for completion items because the user continued to type.
 *
 * To get an instance of a `CancellationToken` use a
 * [CancellationTokenSource](#CancellationTokenSource).</haxe_doc>
	</typedef>
	<class path="vscode.CancellationTokenSource" params="" file="src/vscode/CancellationTokenSource.hx" extern="1">
		<token public="1">
			<t path="vscode.CancellationToken"/>
			<haxe_doc>* The cancellation token of this source.</haxe_doc>
		</token>
		<cancel public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Signal cancellation on the token.</haxe_doc>
		</cancel>
		<dispose public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dispose object and free resources. Will call [cancel](#CancellationTokenSource.cancel).</haxe_doc>
		</dispose>
		<haxe_doc>* A cancellation source creates and controls a [cancellation token](#CancellationToken).</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"CancellationTokenSource"</e>
</m></meta>
	</class>
	<typedef path="vscode.CharacterPair" params="" file="src/vscode/CharacterPair.hx">
		<c path="Array"><c path="String"/></c>
		<haxe_doc>* A tuple of two characters, like a pair of
 * opening and closing brackets.</haxe_doc>
	</typedef>
	<typedef path="vscode.CodeActionContext" params="" file="src/vscode/CodeActionContext.hx">
		<a><diagnostics set="null">
	<c path="Array"><c path="vscode.Diagnostic"/></c>
	<haxe_doc>* An array of diagnostics.
	 *
	 * @readonly</haxe_doc>
</diagnostics></a>
		<haxe_doc>* Contains additional diagnostic information about the context in which
 * a [code action](#CodeActionProvider.provideCodeActions) is run.</haxe_doc>
	</typedef>
	<typedef path="vscode.CodeActionProvider" params="" file="src/vscode/CodeActionProvider.hx">
		<a><provideCodeActions set="method">
	<f a="document:range:context:token">
		<t path="vscode.TextDocument"/>
		<c path="vscode.Range"/>
		<t path="vscode.CodeActionContext"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="Array"><t path="vscode.Command"/></c>
			<t path="js.Thenable"><c path="Array"><t path="vscode.Command"/></c></t>
		</x>
	</f>
	<haxe_doc>* Provide commands for the given document and range.
	 *
	 * @param document The document in which the command was invoked.
	 * @param range The range for which the command was invoked.
	 * @param context Context carrying additional information.
	 * @param token A cancellation token.
	 * @return An array of commands or a thenable of such. The lack of a result can be
	 * signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
</provideCodeActions></a>
		<haxe_doc>* The code action interface defines the contract between extensions and
 * the [light bulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) feature.
 *
 * A code action can be any command that is [known](#commands.getCommands) to the system.</haxe_doc>
	</typedef>
	<class path="vscode.CodeLens" params="" file="src/vscode/CodeLens.hx" extern="1">
		<range public="1">
			<c path="vscode.Range"/>
			<haxe_doc>* The range in which this code lens is valid. Should only span a single line.</haxe_doc>
		</range>
		<command public="1">
			<t path="vscode.Command"/>
			<haxe_doc>* The command this code lens represents.</haxe_doc>
		</command>
		<isResolved public="1">
			<x path="Bool"/>
			<haxe_doc>* `true` when there is a command associated.</haxe_doc>
		</isResolved>
		<new public="1" set="method">
			<f a="range:?command">
				<c path="vscode.Range"/>
				<t path="vscode.Command"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new code lens object.
	 *
	 * @param range The range to which this code lens applies.
	 * @param command The command associated to this code lens.</haxe_doc>
		</new>
		<haxe_doc>* A code lens represents a [command](#Command) that should be shown along with
 * source text, like the number of references, a way to run tests, etc.
 *
 * A code lens is _unresolved_ when no command is associated to it. For performance
 * reasons the creation of a code lens and resolving should be done to two stages.
 *
 * @see [CodeLensProvider.provideCodeLenses](#CodeLensProvider.provideCodeLenses)
 * @see [CodeLensProvider.resolveCodeLens](#CodeLensProvider.resolveCodeLens)</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"CodeLens"</e>
</m></meta>
	</class>
	<typedef path="vscode.CodeLensProvider" params="" file="src/vscode/CodeLensProvider.hx">
		<a>
			<resolveCodeLens set="method">
				<t path="Null"><f a="codeLens:token">
	<c path="vscode.CodeLens"/>
	<t path="vscode.CancellationToken"/>
	<x path="haxe.extern.EitherType">
		<c path="vscode.CodeLens"/>
		<t path="js.Thenable"><c path="vscode.CodeLens"/></t>
	</x>
</f></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* This function will be called for each visible code lens, usually when scrolling and after
	 * calls to [compute](#CodeLensProvider.provideCodeLenses)-lenses.
	 *
	 * @param codeLens code lens that must be resolved.
	 * @param token A cancellation token.
	 * @return The given, resolved code lens or thenable that resolves to such.</haxe_doc>
			</resolveCodeLens>
			<provideCodeLenses set="method">
				<f a="document:token">
					<t path="vscode.TextDocument"/>
					<t path="vscode.CancellationToken"/>
					<x path="haxe.extern.EitherType">
						<c path="Array"><c path="vscode.CodeLens"/></c>
						<t path="js.Thenable"><c path="Array"><c path="vscode.CodeLens"/></c></t>
					</x>
				</f>
				<haxe_doc>* Compute a list of [lenses](#CodeLens). This call should return as fast as possible and if
	 * computing the commands is expensive implementors should only return code lens objects with the
	 * range set and implement [resolve](#CodeLensProvider.resolveCodeLens).
	 *
	 * @param document The document in which the command was invoked.
	 * @param token A cancellation token.
	 * @return An array of code lenses or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
			</provideCodeLenses>
		</a>
		<haxe_doc>* A code lens provider adds [commands](#Command) to source text. The commands will be shown
 * as dedicated horizontal lines in between the source text.</haxe_doc>
	</typedef>
	<typedef path="vscode.Command" params="" file="src/vscode/Command.hx">
		<a>
			<title>
				<c path="String"/>
				<haxe_doc>* Title of the command, like `save`.</haxe_doc>
			</title>
			<command>
				<c path="String"/>
				<haxe_doc>* The identifier of the actual command handler.
	 * @see [commands.registerCommand](#commands.registerCommand).</haxe_doc>
			</command>
			<arguments>
				<t path="Null"><c path="Array"><x path="Any"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Arguments that the command handler should be
	 * invoked with.</haxe_doc>
			</arguments>
		</a>
		<haxe_doc>* Represents a reference to a command. Provides a title which
 * will be used to represent a command in the UI and, optionally,
 * an array of arguments which will be passed to the command handler
 * function when invoked.</haxe_doc>
	</typedef>
	<typedef path="vscode.CommentRule" params="" file="src/vscode/CommentRule.hx">
		<a>
			<lineComment>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The line comment token, like `// this is a comment`</haxe_doc>
			</lineComment>
			<blockComment>
				<t path="Null"><t path="vscode.CharacterPair"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[* The block comment character pair, like `/* block comment *&#47;`]]></haxe_doc>
			</blockComment>
		</a>
		<haxe_doc>* Describes how comments for a language work.</haxe_doc>
	</typedef>
	<class path="vscode.CompletionItem" params="" file="src/vscode/CompletionItem.hx" extern="1">
		<label public="1">
			<c path="String"/>
			<haxe_doc>* The label of this completion item. By default
	 * this is also the text that is inserted when selecting
	 * this completion.</haxe_doc>
		</label>
		<kind public="1">
			<x path="vscode.CompletionItemKind"/>
			<haxe_doc>* The kind of this completion item. Based on the kind
	 * an icon is chosen by the editor.</haxe_doc>
		</kind>
		<detail public="1">
			<c path="String"/>
			<haxe_doc>* A human-readable string with additional information
	 * about this item, like type or symbol information.</haxe_doc>
		</detail>
		<documentation public="1">
			<c path="String"/>
			<haxe_doc>* A human-readable string that represents a doc-comment.</haxe_doc>
		</documentation>
		<sortText public="1">
			<c path="String"/>
			<haxe_doc>* A string that should be used when comparing this item
	 * with other items. When `falsy` the [label](#CompletionItem.label)
	 * is used.</haxe_doc>
		</sortText>
		<filterText public="1">
			<c path="String"/>
			<haxe_doc>* A string that should be used when filtering a set of
	 * completion items. When `falsy` the [label](#CompletionItem.label)
	 * is used.</haxe_doc>
		</filterText>
		<insertText public="1">
			<c path="String"/>
			<haxe_doc>* A string that should be inserted in a document when selecting
	 * this completion. When `falsy` the [label](#CompletionItem.label)
	 * is used.</haxe_doc>
		</insertText>
		<textEdit public="1">
			<c path="vscode.TextEdit"/>
			<haxe_doc>* An [edit](#TextEdit) which is applied to a document when selecting
	 * this completion. When an edit is provided the value of
	 * [insertText](#CompletionItem.insertText) is ignored.
	 *
	 * The [range](#Range) of the edit must be single-line and one the same
	 * line completions where [requested](#CompletionItemProvider.provideCompletionItems) at.</haxe_doc>
		</textEdit>
		<new public="1" set="method">
			<f a="label:?kind">
				<c path="String"/>
				<x path="vscode.CompletionItemKind"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new completion item.
	 *
	 * Completion items must have at least a [label](#CompletionItem.label) which then
	 * will be used as insert text as well as for sorting and filtering.
	 *
	 * @param label The label of the completion.
	 * @param kind The [kind](#CompletionItemKind) of the completion.</haxe_doc>
		</new>
		<haxe_doc>* A completion item represents a text snippet that is
 * proposed to complete text that is being typed.
 *
 * It is suffient to create a completion item from just
 * a [label](#CompletionItem.label). In that case the completion
 * item will replace the [word](#TextDocument.getWordRangeAtPosition)
 * until the cursor with the given label.
 *
 *
 * @see [CompletionItemProvider.provideCompletionItems](#CompletionItemProvider.provideCompletionItems)
 * @see [CompletionItemProvider.resolveCompletionItem](#CompletionItemProvider.resolveCompletionItem)</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"CompletionItem"</e>
</m></meta>
	</class>
	<abstract path="vscode.CompletionItemKind" params="" file="src/vscode/CompletionItemKind.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Completion item kinds.</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"CompletionItemKind"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._CompletionItemKind.CompletionItemKind_Impl_" params="" file="src/vscode/CompletionItemKind.hx" private="1" module="vscode.CompletionItemKind" extern="1">
	<Text public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Text>
	<Method public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Method>
	<Function public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Function>
	<Constructor public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Constructor>
	<Field public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Field>
	<Variable public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Variable>
	<Class public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Class>
	<Interface public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Interface>
	<Module public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Module>
	<Property public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Property>
	<Unit public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Unit>
	<Value public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Value>
	<Enum public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Enum>
	<Keyword public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Keyword>
	<Snippet public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Snippet>
	<Color public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Color>
	<File public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</File>
	<Reference public="1" set="null" static="1">
		<x path="vscode.CompletionItemKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Reference>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"CompletionItemKind"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._CompletionItemKind.CompletionItemKind_Impl_" params="" file="src/vscode/CompletionItemKind.hx" private="1" module="vscode.CompletionItemKind" extern="1">
		<Text public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Text>
		<Method public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Method>
		<Function public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Function>
		<Constructor public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Constructor>
		<Field public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Field>
		<Variable public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Variable>
		<Class public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Class>
		<Interface public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Interface>
		<Module public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Module>
		<Property public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Property>
		<Unit public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Unit>
		<Value public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Value>
		<Enum public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Enum>
		<Keyword public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Keyword>
		<Snippet public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Snippet>
		<Color public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Color>
		<File public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</File>
		<Reference public="1" set="null" static="1">
			<x path="vscode.CompletionItemKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Reference>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"CompletionItemKind"</e>
			</m>
		</meta>
	</class>
	<typedef path="vscode.CompletionItemProvider" params="" file="src/vscode/CompletionItemProvider.hx">
		<a>
			<resolveCompletionItem set="method">
				<t path="Null"><f a="item:token">
	<c path="vscode.CompletionItem"/>
	<t path="vscode.CancellationToken"/>
	<x path="haxe.extern.EitherType">
		<c path="vscode.CompletionItem"/>
		<t path="js.Thenable"><c path="vscode.CompletionItem"/></t>
	</x>
</f></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Given a completion item fill in more data, like [doc-comment](#CompletionItem.documentation)
	 * or [details](#CompletionItem.detail).
	 *
	 * The editor will only resolve a completion item once.
	 *
	 * @param item A completion item currently active in the UI.
	 * @param token A cancellation token.
	 * @return The resolved completion item or a thenable that resolves to of such. It is OK to return the given
	 * `item`. When no result is returned, the given `item` will be used.</haxe_doc>
			</resolveCompletionItem>
			<provideCompletionItems set="method">
				<f a="document:position:token">
					<t path="vscode.TextDocument"/>
					<c path="vscode.Position"/>
					<t path="vscode.CancellationToken"/>
					<x path="haxe.extern.EitherType">
						<c path="Array"><c path="vscode.CompletionItem"/></c>
						<x path="haxe.extern.EitherType">
							<t path="js.Thenable"><c path="Array"><c path="vscode.CompletionItem"/></c></t>
							<x path="haxe.extern.EitherType">
								<c path="vscode.CompletionList"/>
								<t path="js.Thenable"><c path="vscode.CompletionList"/></t>
							</x>
						</x>
					</x>
				</f>
				<haxe_doc>* Provide completion items for the given position and document.
	 *
	 * @param document The document in which the command was invoked.
	 * @param position The position at which the command was invoked.
	 * @param token A cancellation token.
	 * @return An array of completions, a [completion list](#CompletionList), or a thenable that resolves to either.
	 * The lack of a result can be signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
			</provideCompletionItems>
		</a>
		<haxe_doc>* The completion item provider interface defines the contract between extensions and
 * the [IntelliSense](https://code.visualstudio.com/docs/editor/editingevolved#_intellisense).
 *
 * When computing *complete* completion items is expensive, providers can optionally implement
 * the `resolveCompletionItem`-function. In that case it is enough to return completion
 * items with a [label](#CompletionItem.label) from the
 * [provideCompletionItems](#CompletionItemProvider.provideCompletionItems)-function. Subsequently,
 * when a completion item is shown in the UI and gains focus this provider is asked to resolve
 * the item, like adding [doc-comment](#CompletionItem.documentation) or [details](#CompletionItem.detail).</haxe_doc>
	</typedef>
	<class path="vscode.CompletionList" params="" file="src/vscode/CompletionList.hx" extern="1">
		<isIncomplete public="1">
			<x path="Bool"/>
			<haxe_doc>* This list it not complete. Further typing should result in recomputing
	 * this list.</haxe_doc>
		</isIncomplete>
		<items public="1">
			<c path="Array"><c path="vscode.CompletionItem"/></c>
			<haxe_doc>* The completion items.</haxe_doc>
		</items>
		<new public="1" set="method">
			<f a="?items:?isIncomplete">
				<c path="Array"><c path="vscode.CompletionItem"/></c>
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new completion list.
	 *
	 * @param items The completion items.
	 * @param isIncomplete The list is not complete.</haxe_doc>
		</new>
		<haxe_doc>* Represents a collection of [completion items](#CompletionItem) to be presented
 * in the editor.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"CompletionList"</e>
</m></meta>
	</class>
	<typedef path="vscode.DecorationInstanceRenderOptions" params="" file="src/vscode/DecorationInstanceRenderOptions.hx"><a>
	<light>
		<t path="Null"><t path="vscode.ThemableDecorationInstanceRenderOptions"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Overwrite options for light themes.</haxe_doc>
	</light>
	<dark>
		<t path="Null"><t path="vscode.ThemableDecorationInstanceRenderOptions"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Overwrite options for dark themes.</haxe_doc>
	</dark>
	<before>
		<t path="Null"><t path="vscode.ThemableDecorationAttachmentRenderOptions"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Defines the rendering options of the attachment that is inserted before the decorated text</haxe_doc>
	</before>
	<after>
		<t path="Null"><t path="vscode.ThemableDecorationAttachmentRenderOptions"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Defines the rendering options of the attachment that is inserted after the decorated text</haxe_doc>
	</after>
</a></typedef>
	<typedef path="vscode.DecorationOptions" params="" file="src/vscode/DecorationOptions.hx">
		<a>
			<renderOptions>
				<t path="Null"><t path="vscode.DecorationInstanceRenderOptions"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Render options applied to the current decoration. For performance reasons, keep the
	 * number of decoration specific options small, and use decoration types whereever possible.</haxe_doc>
			</renderOptions>
			<range>
				<c path="vscode.Range"/>
				<haxe_doc>* Range to which this decoration is applied.</haxe_doc>
			</range>
			<hoverMessage>
				<x path="haxe.extern.EitherType">
					<t path="vscode.MarkedString"/>
					<c path="Array"><t path="vscode.MarkedString"/></c>
				</x>
				<haxe_doc>* A message that should be rendered when hovering over the decoration.</haxe_doc>
			</hoverMessage>
		</a>
		<haxe_doc>* Represents options for a specific decoration in a [decoration set](#TextEditorDecorationType).</haxe_doc>
	</typedef>
	<typedef path="vscode.DecorationRenderOptions" params="" file="src/vscode/DecorationRenderOptions.hx">
		<a>
			<textDecoration>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</textDecoration>
			<overviewRulerLane>
				<t path="Null"><x path="vscode.OverviewRulerLane"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The position in the overview ruler where the decoration should be rendered.</haxe_doc>
			</overviewRulerLane>
			<overviewRulerColor>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.</haxe_doc>
			</overviewRulerColor>
			<outlineWidth>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'outline' for setting one or more of the individual outline properties.</haxe_doc>
			</outlineWidth>
			<outlineStyle>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'outline' for setting one or more of the individual outline properties.</haxe_doc>
			</outlineStyle>
			<outlineColor>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'outline' for setting one or more of the individual outline properties.</haxe_doc>
			</outlineColor>
			<outline>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</outline>
			<light>
				<t path="Null"><t path="vscode.ThemableDecorationRenderOptions"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Overwrite options for light themes.</haxe_doc>
			</light>
			<letterSpacing>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</letterSpacing>
			<isWholeLine>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Should the decoration be rendered also on the whitespace after the line text.
	 * Defaults to `false`.</haxe_doc>
			</isWholeLine>
			<gutterIconSize>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Specifies the size of the gutter icon.
	 * Available values are 'auto', 'contain', 'cover' and any percentage value.
	 * For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx</haxe_doc>
			</gutterIconSize>
			<gutterIconPath>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* An **absolute path** to an image to be rendered in the gutterIconPath.</haxe_doc>
			</gutterIconPath>
			<dark>
				<t path="Null"><t path="vscode.ThemableDecorationRenderOptions"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Overwrite options for dark themes.</haxe_doc>
			</dark>
			<cursor>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</cursor>
			<color>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</color>
			<borderWidth>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'border' for setting one or more of the individual border properties.</haxe_doc>
			</borderWidth>
			<borderStyle>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'border' for setting one or more of the individual border properties.</haxe_doc>
			</borderStyle>
			<borderSpacing>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'border' for setting one or more of the individual border properties.</haxe_doc>
			</borderSpacing>
			<borderRadius>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'border' for setting one or more of the individual border properties.</haxe_doc>
			</borderRadius>
			<borderColor>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'border' for setting one or more of the individual border properties.</haxe_doc>
			</borderColor>
			<border>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</border>
			<before>
				<t path="Null"><t path="vscode.ThemableDecorationAttachmentRenderOptions"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Defines the rendering options of the attachment that is inserted before the decorated text</haxe_doc>
			</before>
			<backgroundColor>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.</haxe_doc>
			</backgroundColor>
			<after>
				<t path="Null"><t path="vscode.ThemableDecorationAttachmentRenderOptions"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Defines the rendering options of the attachment that is inserted after the decorated text</haxe_doc>
			</after>
		</a>
		<haxe_doc>* Represents rendering styles for a [text editor decoration](#TextEditorDecorationType).</haxe_doc>
	</typedef>
	<typedef path="vscode.Definition" params="" file="src/vscode/Definition.hx">
		<x path="haxe.extern.EitherType">
			<c path="vscode.Location"/>
			<c path="Array"><c path="vscode.Location"/></c>
		</x>
		<haxe_doc>* The definition of a symbol represented as one or many [locations](#Location).
 * For most programming languages there is only one location at which a symbol is
 * defined.</haxe_doc>
	</typedef>
	<typedef path="vscode.DefinitionProvider" params="" file="src/vscode/DefinitionProvider.hx">
		<a><provideDefinition set="method">
	<f a="document:position:token">
		<t path="vscode.TextDocument"/>
		<c path="vscode.Position"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<t path="vscode.Definition"/>
			<t path="js.Thenable"><t path="vscode.Definition"/></t>
		</x>
	</f>
	<haxe_doc>* Provide the definition of the symbol at the given position and document.
	 *
	 * @param document The document in which the command was invoked.
	 * @param position The position at which the command was invoked.
	 * @param token A cancellation token.
	 * @return A definition or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined` or `null`.</haxe_doc>
</provideDefinition></a>
		<haxe_doc>* The definition provider interface defines the contract between extensions and
 * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
 * and peek definition features.</haxe_doc>
	</typedef>
	<class path="vscode.Diagnostic" params="" file="src/vscode/Diagnostic.hx" extern="1">
		<range public="1">
			<c path="vscode.Range"/>
			<haxe_doc>* The range to which this diagnostic applies.</haxe_doc>
		</range>
		<message public="1">
			<c path="String"/>
			<haxe_doc>* The human-readable message.</haxe_doc>
		</message>
		<source public="1">
			<c path="String"/>
			<haxe_doc>* A human-readable string describing the source of this
	 * diagnostic, e.g. 'typescript' or 'super lint'.</haxe_doc>
		</source>
		<severity public="1">
			<x path="vscode.DiagnosticSeverity"/>
			<haxe_doc>* The severity, default is [error](#DiagnosticSeverity.Error).</haxe_doc>
		</severity>
		<code public="1">
			<x path="haxe.extern.EitherType">
				<c path="String"/>
				<x path="Int"/>
			</x>
			<haxe_doc>* A code or identifier for this diagnostics. Will not be surfaced
	 * to the user, but should be used for later processing, e.g. when
	 * providing [code actions](#CodeActionContext).</haxe_doc>
		</code>
		<new public="1" set="method">
			<f a="range:message:?severity">
				<c path="vscode.Range"/>
				<c path="String"/>
				<x path="vscode.DiagnosticSeverity"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new diagnostic object.
	 *
	 * @param range The range to which this diagnostic applies.
	 * @param message The human-readable message.
	 * @param severity The severity, default is [error](#DiagnosticSeverity.Error).</haxe_doc>
		</new>
		<haxe_doc>* Represents a diagnostic, such as a compiler error or warning. Diagnostic objects
 * are only valid in the scope of a file.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"Diagnostic"</e>
</m></meta>
	</class>
	<typedef path="vscode.DiagnosticCollection" params="" file="src/vscode/DiagnosticCollection.hx">
		<a>
			<set set="method">
				<f a="uri:diagnostics">
					<c path="vscode.Uri"/>
					<c path="Array"><c path="vscode.Diagnostic"/></c>
					<x path="Void"/>
				</f>
				<haxe_doc>* Assign diagnostics for given resource. Will replace
	 * existing diagnostics for that resource.
	 *
	 * @param uri A resource identifier.
	 * @param diagnostics Array of diagnostics or `undefined`</haxe_doc>
				<overloads><set public="1" set="method">
	<f a="entries">
		<c path="Array"><c path="Array"><x path="Any"/></c></c>
		<x path="Void"/>
	</f>
	<haxe_doc>* Assign diagnostics for given resource. Will replace
	 * existing diagnostics for that resource.
	 *
	 * @param uri A resource identifier.
	 * @param diagnostics Array of diagnostics or `undefined`</haxe_doc>
</set></overloads>
			</set>
			<name>
				<c path="String"/>
				<haxe_doc>* The name of this diagnostic collection, for instance `typescript`. Every diagnostic
	 * from this collection will be associated with this name. Also, the task framework uses this
	 * name when defining [problem matchers](https://code.visualstudio.com/docs/editor/tasks#_defining-a-problem-matcher).</haxe_doc>
			</name>
			<has set="method">
				<f a="uri">
					<c path="vscode.Uri"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>* Check if this collection contains diagnostics for a
	 * given resource.
	 *
	 * @param uri A resource identifier.
	 * @returns `true` if this collection has diagnostic for the given resource.</haxe_doc>
			</has>
			<get set="method">
				<f a="uri">
					<c path="vscode.Uri"/>
					<c path="Array"><c path="vscode.Diagnostic"/></c>
				</f>
				<haxe_doc>* Get the diagnostics for a given resource. *Note* that you cannot
	 * modify the diagnostics-array returned from this call.
	 *
	 * @param uri A resource identifier.
	 * @returns An immutable array of [diagnostics](#Diagnostic) or `undefined`.</haxe_doc>
			</get>
			<forEach set="method">
				<f a="callback:?thisArg">
					<f a="::">
						<c path="vscode.Uri"/>
						<c path="Array"><c path="vscode.Diagnostic"/></c>
						<t path="vscode.DiagnosticCollection"/>
						<x path="Void"/>
					</f>
					<x path="Any"/>
					<x path="Void"/>
				</f>
				<haxe_doc>* Iterate over each entry in this collection.
	 *
	 * @param callback Function to execute for each entry.
	 * @param thisArg The `this` context used when invoking the handler function.</haxe_doc>
			</forEach>
			<dispose set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>* Dispose and free associated resources. Calls
	 * [clear](#DiagnosticCollection.clear).</haxe_doc>
			</dispose>
			<delete set="method">
				<f a="uri">
					<c path="vscode.Uri"/>
					<x path="Void"/>
				</f>
				<haxe_doc>* Remove all diagnostics from this collection that belong
	 * to the provided `uri`. The same as `#set(uri, undefined)`.
	 *
	 * @param uri A resource identifier.</haxe_doc>
			</delete>
			<clear set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>* Remove all diagnostics from this collection. The same
	 * as calling `#set(undefined)`;</haxe_doc>
			</clear>
		</a>
		<haxe_doc>* A diagnostics collection is a container that manages a set of
 * [diagnostics](#Diagnostic). Diagnostics are always scopes to a
 * diagnostics collection and a resource.
 *
 * To get an instance of a `DiagnosticCollection` use
 * [createDiagnosticCollection](#languages.createDiagnosticCollection).</haxe_doc>
	</typedef>
	<abstract path="vscode.DiagnosticSeverity" params="" file="src/vscode/DiagnosticSeverity.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Represents the severity of diagnostics.</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"DiagnosticSeverity"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._DiagnosticSeverity.DiagnosticSeverity_Impl_" params="" file="src/vscode/DiagnosticSeverity.hx" private="1" module="vscode.DiagnosticSeverity" extern="1">
	<Error public="1" set="null" static="1">
		<x path="vscode.DiagnosticSeverity"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Something not allowed by the rules of a language or other means.</haxe_doc>
	</Error>
	<Warning public="1" set="null" static="1">
		<x path="vscode.DiagnosticSeverity"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Something suspicious but allowed.</haxe_doc>
	</Warning>
	<Information public="1" set="null" static="1">
		<x path="vscode.DiagnosticSeverity"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Something to inform about but not a problem.</haxe_doc>
	</Information>
	<Hint public="1" set="null" static="1">
		<x path="vscode.DiagnosticSeverity"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Something to hint to a better way of doing it, like proposing
	 * a refactoring.</haxe_doc>
	</Hint>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"DiagnosticSeverity"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._DiagnosticSeverity.DiagnosticSeverity_Impl_" params="" file="src/vscode/DiagnosticSeverity.hx" private="1" module="vscode.DiagnosticSeverity" extern="1">
		<Error public="1" set="null" static="1">
			<x path="vscode.DiagnosticSeverity"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Something not allowed by the rules of a language or other means.</haxe_doc>
		</Error>
		<Warning public="1" set="null" static="1">
			<x path="vscode.DiagnosticSeverity"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Something suspicious but allowed.</haxe_doc>
		</Warning>
		<Information public="1" set="null" static="1">
			<x path="vscode.DiagnosticSeverity"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Something to inform about but not a problem.</haxe_doc>
		</Information>
		<Hint public="1" set="null" static="1">
			<x path="vscode.DiagnosticSeverity"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Something to hint to a better way of doing it, like proposing
	 * a refactoring.</haxe_doc>
		</Hint>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"DiagnosticSeverity"</e>
			</m>
		</meta>
	</class>
	<class path="vscode.Disposable" params="" file="src/vscode/Disposable.hx" extern="1">
		<from public="1" set="method" static="1">
			<f a="disposableLikes">
				<x path="haxe.extern.Rest"><a><dispose set="method"><f a=""><x path="Void"/></f></dispose></a></x>
				<c path="vscode.Disposable"/>
			</f>
			<haxe_doc>* Combine many disposable-likes into one. Use this method
	 * when having objects with a dispose function which are not
	 * instances of Disposable.
	 *
	 * @param disposableLikes Objects that have at least a `dispose`-function member.
	 * @return Returns a new disposable which, upon dispose, will
	 * dispose all provided disposables.</haxe_doc>
		</from>
		<dispose public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dispose this object.</haxe_doc>
		</dispose>
		<new public="1" set="method">
			<f a="callOnDispose">
				<x path="haxe.Function"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new Disposable calling the provided function
	 * on dispose.
	 * @param callOnDispose Function that disposes something.</haxe_doc>
		</new>
		<haxe_doc>* Represents a type which can release resources, such
 * as event listening or a timer.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"Disposable"</e>
</m></meta>
	</class>
	<typedef path="vscode.DocumentFilter" params="" file="src/vscode/DocumentFilter.hx">
		<a>
			<scheme>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* A Uri [scheme](#Uri.scheme), like `file` or `untitled`.</haxe_doc>
			</scheme>
			<pattern>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* A glob pattern, like `*.{ts,js}`.</haxe_doc>
			</pattern>
			<language>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* A language id, like `typescript`.</haxe_doc>
			</language>
		</a>
		<haxe_doc>* A document filter denotes a document by different properties like
 * the [language](#TextDocument.languageId), the [scheme](#Uri.scheme) of
 * its resource, or a glob-pattern that is applied to the [path](#TextDocument.fileName).
 *
 * @sample A language filter that applies to typescript files on disk: `{ language: 'typescript', scheme: 'file' }`
 * @sample A language filter that applies to all package.json paths: `{ language: 'json', pattern: '**project.json' }`</haxe_doc>
	</typedef>
	<typedef path="vscode.DocumentFormattingEditProvider" params="" file="src/vscode/DocumentFormattingEditProvider.hx">
		<a><provideDocumentFormattingEdits set="method">
	<f a="document:options:token">
		<t path="vscode.TextDocument"/>
		<t path="vscode.FormattingOptions"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="Array"><c path="vscode.TextEdit"/></c>
			<t path="js.Thenable"><c path="Array"><c path="vscode.TextEdit"/></c></t>
		</x>
	</f>
	<haxe_doc>* Provide formatting edits for a whole document.
	 *
	 * @param document The document in which the command was invoked.
	 * @param options Options controlling formatting.
	 * @param token A cancellation token.
	 * @return A set of text edits or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
</provideDocumentFormattingEdits></a>
		<haxe_doc>* The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.</haxe_doc>
	</typedef>
	<class path="vscode.DocumentHighlight" params="" file="src/vscode/DocumentHighlight.hx" extern="1">
		<range public="1">
			<c path="vscode.Range"/>
			<haxe_doc>* The range this highlight applies to.</haxe_doc>
		</range>
		<kind public="1">
			<x path="vscode.DocumentHighlightKind"/>
			<haxe_doc>* The highlight kind, default is [text](#DocumentHighlightKind.Text).</haxe_doc>
		</kind>
		<new public="1" set="method">
			<f a="range:?kind">
				<c path="vscode.Range"/>
				<x path="vscode.DocumentHighlightKind"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new document highlight object.
	 *
	 * @param range The range the highlight applies to.
	 * @param kind The highlight kind, default is [text](#DocumentHighlightKind.Text).</haxe_doc>
		</new>
		<haxe_doc>* A document highlight is a range inside a text document which deserves
 * special attention. Usually a document highlight is visualized by changing
 * the background color of its range.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"DocumentHighlight"</e>
</m></meta>
	</class>
	<abstract path="vscode.DocumentHighlightKind" params="" file="src/vscode/DocumentHighlightKind.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* A document highlight kind.</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"DocumentHighlightKind"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._DocumentHighlightKind.DocumentHighlightKind_Impl_" params="" file="src/vscode/DocumentHighlightKind.hx" private="1" module="vscode.DocumentHighlightKind" extern="1">
	<Text public="1" set="null" static="1">
		<x path="vscode.DocumentHighlightKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* A textual occurrence.</haxe_doc>
	</Text>
	<Read public="1" set="null" static="1">
		<x path="vscode.DocumentHighlightKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Read-access of a symbol, like reading a variable.</haxe_doc>
	</Read>
	<Write public="1" set="null" static="1">
		<x path="vscode.DocumentHighlightKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Write-access of a symbol, like writing to a variable.</haxe_doc>
	</Write>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"DocumentHighlightKind"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._DocumentHighlightKind.DocumentHighlightKind_Impl_" params="" file="src/vscode/DocumentHighlightKind.hx" private="1" module="vscode.DocumentHighlightKind" extern="1">
		<Text public="1" set="null" static="1">
			<x path="vscode.DocumentHighlightKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* A textual occurrence.</haxe_doc>
		</Text>
		<Read public="1" set="null" static="1">
			<x path="vscode.DocumentHighlightKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Read-access of a symbol, like reading a variable.</haxe_doc>
		</Read>
		<Write public="1" set="null" static="1">
			<x path="vscode.DocumentHighlightKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Write-access of a symbol, like writing to a variable.</haxe_doc>
		</Write>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"DocumentHighlightKind"</e>
			</m>
		</meta>
	</class>
	<typedef path="vscode.DocumentHighlightProvider" params="" file="src/vscode/DocumentHighlightProvider.hx">
		<a><provideDocumentHighlights set="method">
	<f a="document:position:token">
		<t path="vscode.TextDocument"/>
		<c path="vscode.Position"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="Array"><c path="vscode.DocumentHighlight"/></c>
			<t path="js.Thenable"><c path="Array"><c path="vscode.DocumentHighlight"/></c></t>
		</x>
	</f>
	<haxe_doc>* Provide a set of document highlights, like all occurrences of a variable or
	 * all exit-points of a function.
	 *
	 * @param document The document in which the command was invoked.
	 * @param position The position at which the command was invoked.
	 * @param token A cancellation token.
	 * @return An array of document highlights or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
</provideDocumentHighlights></a>
		<haxe_doc>* The document highlight provider interface defines the contract between extensions and
 * the word-highlight-feature.</haxe_doc>
	</typedef>
	<class path="vscode.DocumentLink" params="" file="src/vscode/DocumentLink.hx" extern="1">
		<range public="1">
			<c path="vscode.Range"/>
			<haxe_doc>* The range this link applies to.</haxe_doc>
		</range>
		<target public="1">
			<c path="vscode.Uri"/>
			<haxe_doc>* The uri this link points to.</haxe_doc>
		</target>
		<new public="1" set="method">
			<f a="range:target">
				<c path="vscode.Range"/>
				<c path="vscode.Uri"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new document link.
	 *
	 * @param range The range the document link applies to. Must not be empty.
	 * @param target The uri the document link points to.</haxe_doc>
		</new>
		<haxe_doc>* A document link is a range in a text document that links to an internal or external resource, like another
 * text document or a web site.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"DocumentLink"</e>
</m></meta>
	</class>
	<typedef path="vscode.DocumentLinkProvider" params="" file="src/vscode/DocumentLinkProvider.hx">
		<a><provideDocumentLinks set="method">
	<f a="document:token">
		<t path="vscode.TextDocument"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="Array"><c path="vscode.DocumentLink"/></c>
			<t path="js.Thenable"><c path="Array"><c path="vscode.DocumentLink"/></c></t>
		</x>
	</f>
	<haxe_doc>* @param document The document in which the command was invoked.
	 * @param token A cancellation token.
	 * @return An array of [document links](#DocumentLink) or a thenable that resolves to such. The lack of a result
	 *  can be signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
</provideDocumentLinks></a>
		<haxe_doc>* The document link provider defines the contract between extensions and feature of showing
 * links in the editor.</haxe_doc>
	</typedef>
	<typedef path="vscode.DocumentRangeFormattingEditProvider" params="" file="src/vscode/DocumentRangeFormattingEditProvider.hx">
		<a><provideDocumentRangeFormattingEdits set="method">
	<f a="document:range:options:token">
		<t path="vscode.TextDocument"/>
		<c path="vscode.Range"/>
		<t path="vscode.FormattingOptions"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="Array"><c path="vscode.TextEdit"/></c>
			<t path="js.Thenable"><c path="Array"><c path="vscode.TextEdit"/></c></t>
		</x>
	</f>
	<haxe_doc>* Provide formatting edits for a range in a document.
	 *
	 * The given range is a hint and providers can decide to format a smaller
	 * or larger range. Often this is done by adjusting the start and end
	 * of the range to full syntax nodes.
	 *
	 * @param document The document in which the command was invoked.
	 * @param range The range which should be formatted.
	 * @param options Options controlling formatting.
	 * @param token A cancellation token.
	 * @return A set of text edits or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
</provideDocumentRangeFormattingEdits></a>
		<haxe_doc>* The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.</haxe_doc>
	</typedef>
	<typedef path="vscode.DocumentSelector" params="" file="src/vscode/DocumentSelector.hx">
		<x path="haxe.extern.EitherType">
			<t path="vscode._DocumentSelector.DocumentSelectorSimple"/>
			<c path="Array"><t path="vscode._DocumentSelector.DocumentSelectorSimple"/></c>
		</x>
		<haxe_doc>* A language selector is the combination of one or many language identifiers
 * and [language filters](#DocumentFilter).
 *
 * @sample `let sel:DocumentSelector = 'typescript'`;
 * @sample `let sel:DocumentSelector = ['typescript', { language: 'json', pattern: '**tsconfig.json' }]`;</haxe_doc>
	</typedef>
	<typedef path="vscode._DocumentSelector.DocumentSelectorSimple" params="" file="src/vscode/DocumentSelector.hx" private="1" module="vscode.DocumentSelector"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<t path="vscode.DocumentFilter"/>
</x></typedef>
	<typedef path="vscode.DocumentSymbolProvider" params="" file="src/vscode/DocumentSymbolProvider.hx">
		<a><provideDocumentSymbols set="method">
	<f a="document:token">
		<t path="vscode.TextDocument"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="Array"><c path="vscode.SymbolInformation"/></c>
			<t path="js.Thenable"><c path="Array"><c path="vscode.SymbolInformation"/></c></t>
		</x>
	</f>
	<haxe_doc>* Provide symbol information for the given document.
	 *
	 * @param document The document in which the command was invoked.
	 * @param token A cancellation token.
	 * @return An array of document highlights or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
</provideDocumentSymbols></a>
		<haxe_doc>* The document symbol provider interface defines the contract between extensions and
 * the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_goto-symbol)-feature.</haxe_doc>
	</typedef>
	<abstract path="vscode.EndOfLine" params="" file="src/vscode/EndOfLine.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Represents an end of line character sequence in a [document](#TextDocument).</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"EndOfLine"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._EndOfLine.EndOfLine_Impl_" params="" file="src/vscode/EndOfLine.hx" private="1" module="vscode.EndOfLine" extern="1">
	<LF public="1" set="null" static="1">
		<x path="vscode.EndOfLine"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* The line feed `\n` character.</haxe_doc>
	</LF>
	<CRLF public="1" set="null" static="1">
		<x path="vscode.EndOfLine"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* The carriage return line feed `\r\n` sequence.</haxe_doc>
	</CRLF>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"EndOfLine"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._EndOfLine.EndOfLine_Impl_" params="" file="src/vscode/EndOfLine.hx" private="1" module="vscode.EndOfLine" extern="1">
		<LF public="1" set="null" static="1">
			<x path="vscode.EndOfLine"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* The line feed `\n` character.</haxe_doc>
		</LF>
		<CRLF public="1" set="null" static="1">
			<x path="vscode.EndOfLine"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* The carriage return line feed `\r\n` sequence.</haxe_doc>
		</CRLF>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"EndOfLine"</e>
			</m>
		</meta>
	</class>
	<typedef path="vscode.EnterAction" params="" file="src/vscode/EnterAction.hx">
		<a>
			<removeText>
				<t path="Null"><x path="Int"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Describes the number of characters to remove from the new line's indentation.</haxe_doc>
			</removeText>
			<indentAction>
				<x path="vscode.IndentAction"/>
				<haxe_doc>* Describe what to do with the indentation.</haxe_doc>
			</indentAction>
			<appendText>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Describes text to be appended after the new line and after the indentation.</haxe_doc>
			</appendText>
		</a>
		<haxe_doc>* Describes what to do when pressing Enter.</haxe_doc>
	</typedef>
	<typedef path="vscode.Event" params="T" file="src/vscode/Event.hx">
		<f a=":?:?">
			<f a="">
				<c path="vscode.Event.T"/>
				<x path="Void"/>
			</f>
			<x path="Any"/>
			<c path="Array"><c path="vscode.Disposable"/></c>
			<c path="vscode.Disposable"/>
		</f>
		<haxe_doc>* Represents a typed event.
 *
 * A function that represents an event to which you subscribe by calling it with
 * a listener function as argument.
 *
 * @param listener The listener function will be called when the event happens.
 * @param thisArgs The `this`-argument which will be used when calling the event listener.
 * @param disposables An array to which a [disposeable](#Disposable) will be added.
 * @return A disposable which unsubscribes the event listener.
 *
 * @sample `item.onDidChange(function(event) { console.log("Event happened: " + event); });`</haxe_doc>
	</typedef>
	<class path="vscode.EventEmitter" params="T" file="src/vscode/EventEmitter.hx" extern="1">
		<event public="1">
			<t path="vscode.Event"><c path="vscode.EventEmitter.T"/></t>
			<haxe_doc>* The event listeners can subscribe to.</haxe_doc>
		</event>
		<fire public="1" set="method">
			<f a="?data">
				<c path="vscode.EventEmitter.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Notify all subscribers of the [event](EventEmitter#event). Failure
	 * of one or more listener will not fail this function call.
	 *
	 * @param data The event object.</haxe_doc>
		</fire>
		<dispose public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Dispose this object and free resources.</haxe_doc>
		</dispose>
		<haxe_doc>* An event emitter can be used to create and manage an [event](#Event) for others
 * to subscribe to. One emitter always owns one event.
 *
 * Use this class if you want to provide event from within your extension, for instance
 * inside a [TextDocumentContentProvider](#TextDocumentContentProvider) or when providing
 * API to other extensions.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"EventEmitter"</e>
</m></meta>
	</class>
	<typedef path="vscode.Extension" params="T" file="src/vscode/Extension.hx">
		<a>
			<packageJSON set="null">
				<x path="Any"/>
				<haxe_doc>* The parsed contents of the extension's package.json.
	 *
	 * @readonly</haxe_doc>
			</packageJSON>
			<isActive set="null">
				<x path="Bool"/>
				<haxe_doc>* `true` if the extension has been activated.
	 *
	 * @readonly</haxe_doc>
			</isActive>
			<id set="null">
				<c path="String"/>
				<haxe_doc>* The canonical extension identifier in the form of: `publisher.name`.
	 *
	 * @readonly</haxe_doc>
			</id>
			<extensionPath set="null">
				<c path="String"/>
				<haxe_doc>* The absolute file path of the directory containing this extension.
	 *
	 * @readonly</haxe_doc>
			</extensionPath>
			<exports>
				<c path="vscode.Extension.T"/>
				<haxe_doc>* The public API exported by this extension. It is an invalid action
	 * to access this field before this extension has been activated.
	 *
	 * @readonly</haxe_doc>
			</exports>
			<activate set="method">
				<f a=""><t path="js.Thenable"><c path="vscode.Extension.T"/></t></f>
				<haxe_doc>* Activates this extension and returns its public API.
	 *
	 * @return A promise that will resolve when this extension has been activated.</haxe_doc>
			</activate>
		</a>
		<haxe_doc>* Represents an extension.
 *
 * To get an instance of an `Extension` use [getExtension](#extensions.getExtension).</haxe_doc>
	</typedef>
	<typedef path="vscode.ExtensionContext" params="" file="src/vscode/ExtensionContext.hx">
		<a>
			<workspaceState>
				<t path="vscode.Memento"/>
				<haxe_doc>* A memento object that stores state in the context
	 * of the currently opened [workspace](#workspace.rootPath).</haxe_doc>
			</workspaceState>
			<subscriptions>
				<c path="Array"><a><dispose set="method"><f a=""><x path="Void"/></f></dispose></a></c>
				<haxe_doc>* An array to which disposables can be added. When this
	 * extension is deactivated the disposables will be disposed.</haxe_doc>
			</subscriptions>
			<storagePath>
				<c path="String"/>
				<haxe_doc>* An absolute file path of a workspace specific directory in which the extension
	 * can store private state. The directory might not exist on disk and creation is
	 * up to the extension. However, the parent directory is guaranteed to be existent.
	 *
	 * Use [`workspaceState`](ExtensionContext#workspaceState) or
	 * [`globalState`](ExtensionContext#globalState) to store key value data.</haxe_doc>
			</storagePath>
			<globalState>
				<t path="vscode.Memento"/>
				<haxe_doc>* A memento object that stores state independent
	 * of the current opened [workspace](#workspace.rootPath).</haxe_doc>
			</globalState>
			<extensionPath>
				<c path="String"/>
				<haxe_doc>* The absolute file path of the directory containing the extension.</haxe_doc>
			</extensionPath>
			<asAbsolutePath set="method">
				<f a="relativePath">
					<c path="String"/>
					<c path="String"/>
				</f>
				<haxe_doc>* Get the absolute path of a resource contained in the extension.
	 *
	 * @param relativePath A relative path to a resource contained in the extension.
	 * @return The absolute path of the resource.</haxe_doc>
			</asAbsolutePath>
		</a>
		<haxe_doc>* An extension context is a collection of utilities private to an
 * extension.
 *
 * An instance of an `ExtensionContext` is provided as the first
 * parameter to the `activate`-call of an extension.</haxe_doc>
	</typedef>
	<class path="vscode.FileSystemWatcher" params="" file="src/vscode/FileSystemWatcher.hx" extern="1">
		<extends path="vscode.Disposable"/>
		<ignoreCreateEvents public="1">
			<x path="Bool"/>
			<haxe_doc>* true if this file system watcher has been created such that
	 * it ignores creation file system events.</haxe_doc>
		</ignoreCreateEvents>
		<ignoreChangeEvents public="1">
			<x path="Bool"/>
			<haxe_doc>* true if this file system watcher has been created such that
	 * it ignores change file system events.</haxe_doc>
		</ignoreChangeEvents>
		<ignoreDeleteEvents public="1">
			<x path="Bool"/>
			<haxe_doc>* true if this file system watcher has been created such that
	 * it ignores delete file system events.</haxe_doc>
		</ignoreDeleteEvents>
		<onDidCreate public="1">
			<t path="vscode.Event"><c path="vscode.Uri"/></t>
			<haxe_doc>* An event which fires on file/folder creation.</haxe_doc>
		</onDidCreate>
		<onDidChange public="1">
			<t path="vscode.Event"><c path="vscode.Uri"/></t>
			<haxe_doc>* An event which fires on file/folder change.</haxe_doc>
		</onDidChange>
		<onDidDelete public="1">
			<t path="vscode.Event"><c path="vscode.Uri"/></t>
			<haxe_doc>* An event which fires on file/folder deletion.</haxe_doc>
		</onDidDelete>
		<haxe_doc>* A file system watcher notifies about changes to files and folders
 * on disk.
 *
 * To get an instance of a `FileSystemWatcher` use
 * [createFileSystemWatcher](#workspace.createFileSystemWatcher).</haxe_doc>
	</class>
	<typedef path="vscode.FormattingOptions" params="" file="src/vscode/FormattingOptions.hx">
		<a>
			<tabSize>
				<x path="Int"/>
				<haxe_doc>* Size of a tab in spaces.</haxe_doc>
			</tabSize>
			<insertSpaces>
				<x path="Bool"/>
				<haxe_doc>* Prefer spaces over tabs.</haxe_doc>
			</insertSpaces>
		</a>
		<haxe_doc>* Value-object describing what options formatting should use.</haxe_doc>
	</typedef>
	<class path="vscode.Hover" params="" file="src/vscode/Hover.hx" extern="1">
		<contents public="1">
			<c path="Array"><t path="vscode.MarkedString"/></c>
			<haxe_doc>* The contents of this hover.</haxe_doc>
		</contents>
		<range public="1">
			<c path="vscode.Range"/>
			<haxe_doc>* The range to which this hover applies. When missing, the
	 * editor will use the range at the current position or the
	 * current position itself.</haxe_doc>
		</range>
		<new public="1" set="method">
			<f a="contents:?range">
				<x path="haxe.extern.EitherType">
					<t path="vscode.MarkedString"/>
					<c path="Array"><t path="vscode.MarkedString"/></c>
				</x>
				<c path="vscode.Range"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new hover object.
	 *
	 * @param contents The contents of the hover.
	 * @param range The range to which the hover applies.</haxe_doc>
		</new>
		<haxe_doc>* A hover represents additional information for a symbol or word. Hovers are
 * rendered in a tooltip-like widget.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"Hover"</e>
</m></meta>
	</class>
	<typedef path="vscode.HoverProvider" params="" file="src/vscode/HoverProvider.hx">
		<a><provideHover set="method">
	<f a="document:position:token">
		<t path="vscode.TextDocument"/>
		<c path="vscode.Position"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="vscode.Hover"/>
			<t path="js.Thenable"><c path="vscode.Hover"/></t>
		</x>
	</f>
	<haxe_doc>* Provide a hover for the given position and document. Multiple hovers at the same
	 * position will be merged by the editor. A hover can have a range which defaults
	 * to the word range at the position when omitted.
	 *
	 * @param document The document in which the command was invoked.
	 * @param position The position at which the command was invoked.
	 * @param token A cancellation token.
	 * @return A hover or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined` or `null`.</haxe_doc>
</provideHover></a>
		<haxe_doc>* The hover provider interface defines the contract between extensions and
 * the [hover](https://code.visualstudio.com/docs/editor/editingevolved#_hover)-feature.</haxe_doc>
	</typedef>
	<abstract path="vscode.IndentAction" params="" file="src/vscode/IndentAction.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Describes what to do with the indentation when pressing Enter.</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"IndentAction"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._IndentAction.IndentAction_Impl_" params="" file="src/vscode/IndentAction.hx" private="1" module="vscode.IndentAction" extern="1">
	<None public="1" set="null" static="1">
		<x path="vscode.IndentAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Insert new line and copy the previous line's indentation.</haxe_doc>
	</None>
	<Indent public="1" set="null" static="1">
		<x path="vscode.IndentAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Insert new line and indent once (relative to the previous line's indentation).</haxe_doc>
	</Indent>
	<IndentOutdent public="1" set="null" static="1">
		<x path="vscode.IndentAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Insert two new lines:
	 *  - the first one indented which will hold the cursor
	 *  - the second one at the same indentation level</haxe_doc>
	</IndentOutdent>
	<Outdent public="1" set="null" static="1">
		<x path="vscode.IndentAction"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Insert new line and outdent once (relative to the previous line's indentation).</haxe_doc>
	</Outdent>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"IndentAction"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._IndentAction.IndentAction_Impl_" params="" file="src/vscode/IndentAction.hx" private="1" module="vscode.IndentAction" extern="1">
		<None public="1" set="null" static="1">
			<x path="vscode.IndentAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Insert new line and copy the previous line's indentation.</haxe_doc>
		</None>
		<Indent public="1" set="null" static="1">
			<x path="vscode.IndentAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Insert new line and indent once (relative to the previous line's indentation).</haxe_doc>
		</Indent>
		<IndentOutdent public="1" set="null" static="1">
			<x path="vscode.IndentAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Insert two new lines:
	 *  - the first one indented which will hold the cursor
	 *  - the second one at the same indentation level</haxe_doc>
		</IndentOutdent>
		<Outdent public="1" set="null" static="1">
			<x path="vscode.IndentAction"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Insert new line and outdent once (relative to the previous line's indentation).</haxe_doc>
		</Outdent>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"IndentAction"</e>
			</m>
		</meta>
	</class>
	<typedef path="vscode.IndentationRule" params="" file="src/vscode/IndentationRule.hx">
		<a>
			<unIndentedLinePattern>
				<t path="Null"><c path="js.RegExp"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* If a line matches this pattern, then its indentation should not be changed and it should not be evaluated against the other rules.</haxe_doc>
			</unIndentedLinePattern>
			<indentNextLinePattern>
				<t path="Null"><c path="js.RegExp"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* If a line matches this pattern, then **only the next line** after it should be indented once.</haxe_doc>
			</indentNextLinePattern>
			<increaseIndentPattern>
				<c path="js.RegExp"/>
				<haxe_doc>* If a line matches this pattern, then all the lines after it should be indented once (until another rule matches).</haxe_doc>
			</increaseIndentPattern>
			<decreaseIndentPattern>
				<c path="js.RegExp"/>
				<haxe_doc>* If a line matches this pattern, then all the lines after it should be unindendented once (until another rule matches).</haxe_doc>
			</decreaseIndentPattern>
		</a>
		<haxe_doc>* Describes indentation rules for a language.</haxe_doc>
	</typedef>
	<typedef path="vscode.InputBoxOptions" params="" file="src/vscode/InputBoxOptions.hx">
		<a>
			<value>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The value to prefill in the input box.</haxe_doc>
			</value>
			<validateInput>
				<t path="Null"><f a="">
	<c path="String"/>
	<c path="String"/>
</f></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* An optional function that will be called to valide input and to give a hint
	 * to the user.
	 *
	 * @param value The current value of the input box.
	 * @return A human readable string which is presented as diagnostic message.
	 * Return `undefined`, `null`, or the empty string when 'value' is valid.</haxe_doc>
			</validateInput>
			<prompt>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The text to display underneath the input box.</haxe_doc>
			</prompt>
			<placeHolder>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* An optional string to show as place holder in the input box to guide the user what to type.</haxe_doc>
			</placeHolder>
			<password>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Set to true to show a password prompt that will not show the typed value.</haxe_doc>
			</password>
		</a>
		<haxe_doc>* Options to configure the behavior of the input box UI.</haxe_doc>
	</typedef>
	<typedef path="vscode.LanguageConfiguration" params="" file="src/vscode/LanguageConfiguration.hx">
		<a>
			<wordPattern>
				<t path="Null"><c path="js.RegExp"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc><![CDATA[* The language's word definition.
	 * If the language supports Unicode identifiers (e.g. JavaScript), it is preferable
	 * to provide a word definition that uses exclusion of known separators.
	 * e.g.: A regex that matches anything except known separators (and dot is allowed to occur in a floating point number):
	 *   /(-?\d*\.\d\w*)|([^\`\~\!\@\#\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g]]></haxe_doc>
			</wordPattern>
			<onEnterRules>
				<t path="Null"><c path="Array"><t path="vscode.OnEnterRule"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The language's rules to be evaluated when pressing Enter.</haxe_doc>
			</onEnterRules>
			<indentationRules>
				<t path="Null"><t path="vscode.IndentationRule"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The language's indentation settings.</haxe_doc>
			</indentationRules>
			<comments>
				<t path="Null"><t path="vscode.CommentRule"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The language's comment settings.</haxe_doc>
			</comments>
			<brackets>
				<t path="Null"><c path="Array"><t path="vscode.CharacterPair"/></c></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The language's brackets.
	 * This configuration implicitly affects pressing Enter around these brackets.</haxe_doc>
			</brackets>
			<__electricCharacterSupport>
				<t path="Null"><a>
	<docComment>
		<t path="Null"><a>
	<scope><c path="String"/></scope>
	<open><c path="String"/></open>
	<lineStart><c path="String"/></lineStart>
	<close>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
	</close>
</a></t>
		<meta>
			<m n=":deprecated"/>
			<m n=":optional"/>
		</meta>
		<haxe_doc>* This property is deprecated and not fully supported anymore by
		 * the editor (scope and lineStart are ignored).
		 * Use the the autoClosingPairs property in the language configuration file instead.
		 * @deprecated</haxe_doc>
	</docComment>
	<brackets>
		<t path="Null"><x path="Any"/></t>
		<meta>
			<m n=":deprecated"/>
			<m n=":optional"/>
		</meta>
		<haxe_doc>* This property is deprecated and will be **ignored** from
		 * the editor.
		 * @deprecated</haxe_doc>
	</brackets>
</a></t>
				<meta>
					<m n=":deprecated"><e>"Will be replaced by a better API soon."</e></m>
					<m n=":optional"/>
				</meta>
				<haxe_doc>* **Deprecated** Do not use.
	 *
	 * @deprecated Will be replaced by a better API soon.</haxe_doc>
			</__electricCharacterSupport>
			<__characterPairSupport>
				<t path="Null"><a><autoClosingPairs><c path="Array"><a>
	<open><c path="String"/></open>
	<notIn>
		<t path="Null"><c path="Array"><c path="String"/></c></t>
		<meta><m n=":optional"/></meta>
	</notIn>
	<close><c path="String"/></close>
</a></c></autoClosingPairs></a></t>
				<meta>
					<m n=":deprecated"><e>"Use the the autoClosingPairs property in the language configuration file instead."</e></m>
					<m n=":optional"/>
				</meta>
				<haxe_doc>* **Deprecated** Do not use.
	 *
	 * @deprecated * Use the the autoClosingPairs property in the language configuration file instead.</haxe_doc>
			</__characterPairSupport>
		</a>
		<haxe_doc>* The language configuration interfaces defines the contract between extensions
 * and various editor features, like automatic bracket insertion, automatic indentation etc.</haxe_doc>
	</typedef>
	<class path="vscode.Location" params="" file="src/vscode/Location.hx" extern="1">
		<uri public="1">
			<c path="vscode.Uri"/>
			<haxe_doc>* The resource identifier of this location.</haxe_doc>
		</uri>
		<range public="1">
			<c path="vscode.Range"/>
			<haxe_doc>* The document range of this locations.</haxe_doc>
		</range>
		<new public="1" set="method">
			<f a="uri:rangeOrPosition">
				<c path="vscode.Uri"/>
				<x path="haxe.extern.EitherType">
					<c path="vscode.Range"/>
					<c path="vscode.Position"/>
				</x>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new location object.
	 *
	 * @param uri The resource identifier.
	 * @param rangeOrPosition The range or position. Positions will be converted to an empty range.</haxe_doc>
		</new>
		<haxe_doc>* Represents a location inside a resource, such as a line
 * inside a text file.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"Location"</e>
</m></meta>
	</class>
	<typedef path="vscode.MarkedString" params="" file="src/vscode/MarkedString.hx">
		<x path="haxe.extern.EitherType">
			<c path="String"/>
			<a>
				<value><c path="String"/></value>
				<language><c path="String"/></language>
			</a>
		</x>
		<haxe_doc>* MarkedString can be used to render human readable text. It is either a markdown string
 * or a code-block that provides a language and a code snippet. Note that
 * markdown strings will be sanitized - that means html will be escaped.</haxe_doc>
	</typedef>
	<typedef path="vscode.Memento" params="" file="src/vscode/Memento.hx">
		<a>
			<update set="method">
				<f a="key:value">
					<c path="String"/>
					<x path="Any"/>
					<t path="js.Thenable"><x path="Void"/></t>
				</f>
				<haxe_doc>* Store a value. The value must be JSON-stringifyable.
	 *
	 * @param key A string.
	 * @param value A value. MUST not contain cyclic references.</haxe_doc>
			</update>
			<get params="T" set="method">
				<f a="key:?defaultValue">
					<c path="String"/>
					<c path="get.T"/>
					<c path="get.T"/>
				</f>
				<haxe_doc>* Return a value.
	 *
	 * @param key A string.
	 * @param defaultValue A value that should be returned when there is no
	 * value (`undefined`) with the given key.
	 * @return The stored value, `undefined`, or the defaultValue.</haxe_doc>
			</get>
		</a>
		<haxe_doc>* A memento represents a storage utility. It can store and retrieve
 * values.</haxe_doc>
	</typedef>
	<typedef path="vscode.MessageItem" params="" file="src/vscode/MessageItem.hx">
		<a>
			<title>
				<c path="String"/>
				<haxe_doc>* A short title like 'Retry', 'Open Log' etc.</haxe_doc>
			</title>
			<isCloseAffordance>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Indicates that this item replaces the default
	 * 'Close' action.</haxe_doc>
			</isCloseAffordance>
		</a>
		<haxe_doc>* Represents an action that is shown with an information, warning, or
 * error message.
 *
 * @see [showInformationMessage](#window.showInformationMessage)
 * @see [showWarningMessage](#window.showWarningMessage)
 * @see [showErrorMessage](#window.showErrorMessage)</haxe_doc>
	</typedef>
	<typedef path="vscode.OnEnterRule" params="" file="src/vscode/OnEnterRule.hx">
		<a>
			<beforeText>
				<c path="js.RegExp"/>
				<haxe_doc>* This rule will only execute if the text before the cursor matches this regular expression.</haxe_doc>
			</beforeText>
			<afterText>
				<t path="Null"><c path="js.RegExp"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* This rule will only execute if the text after the cursor matches this regular expression.</haxe_doc>
			</afterText>
			<action>
				<t path="vscode.EnterAction"/>
				<haxe_doc>* The action to execute.</haxe_doc>
			</action>
		</a>
		<haxe_doc>* Describes a rule to be evaluated when pressing Enter.</haxe_doc>
	</typedef>
	<typedef path="vscode.OnTypeFormattingEditProvider" params="" file="src/vscode/OnTypeFormattingEditProvider.hx">
		<a><provideOnTypeFormattingEdits set="method">
	<f a="document:position:ch:options:token">
		<t path="vscode.TextDocument"/>
		<c path="vscode.Position"/>
		<c path="String"/>
		<t path="vscode.FormattingOptions"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="Array"><c path="vscode.TextEdit"/></c>
			<t path="js.Thenable"><c path="Array"><c path="vscode.TextEdit"/></c></t>
		</x>
	</f>
	<haxe_doc>* Provide formatting edits after a character has been typed.
	 *
	 * The given position and character should hint to the provider
	 * what range the position to expand to, like find the matching `{`
	 * when `}` has been entered.
	 *
	 * @param document The document in which the command was invoked.
	 * @param position The position at which the command was invoked.
	 * @param ch The character that has been typed.
	 * @param options Options controlling formatting.
	 * @param token A cancellation token.
	 * @return A set of text edits or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
</provideOnTypeFormattingEdits></a>
		<haxe_doc>* The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.</haxe_doc>
	</typedef>
	<typedef path="vscode.OutputChannel" params="" file="src/vscode/OutputChannel.hx">
		<a>
			<show set="method">
				<f a="?preserveFocus">
					<x path="Bool"/>
					<x path="Void"/>
				</f>
				<haxe_doc>* Reveal this channel in the UI.
	 *
	 * @param preserveFocus When `true` the channel will not take focus.</haxe_doc>
				<overloads><show public="1" set="method">
	<f a="?column:?preservceFocus">
		<x path="vscode.ViewColumn"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* Reveal this channel in the UI.
	 *
	 * @param preserveFocus When `true` the channel will not take focus.</haxe_doc>
</show></overloads>
			</show>
			<name>
				<c path="String"/>
				<haxe_doc>* The human-readable name of this output channel.
	 * @readonly</haxe_doc>
			</name>
			<hide set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>* Hide this channel from the UI.</haxe_doc>
			</hide>
			<dispose set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>* Dispose and free associated resources.</haxe_doc>
			</dispose>
			<clear set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>* Removes all output from the channel.</haxe_doc>
			</clear>
			<appendLine set="method">
				<f a="value">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>* Append the given value and a line feed character
	 * to the channel.
	 *
	 * @param value A string, falsy values will be printed.</haxe_doc>
			</appendLine>
			<append set="method">
				<f a="value">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>* Append the given value to the channel.
	 *
	 * @param value A string, falsy values will not be printed.</haxe_doc>
			</append>
		</a>
		<haxe_doc>* An output channel is a container for readonly textual information.
 *
 * To get an instance of an `OutputChannel` use
 * [createOutputChannel](#window.createOutputChannel).</haxe_doc>
	</typedef>
	<abstract path="vscode.OverviewRulerLane" params="" file="src/vscode/OverviewRulerLane.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Represents different positions for rendering a decoration in an [overview ruler](#DecorationRenderOptions.overviewRulerLane).
 * The overview ruler supports three lanes.</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"OverviewRulerLane"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._OverviewRulerLane.OverviewRulerLane_Impl_" params="" file="src/vscode/OverviewRulerLane.hx" private="1" module="vscode.OverviewRulerLane" extern="1">
	<Left public="1" set="null" static="1">
		<x path="vscode.OverviewRulerLane"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Left>
	<Center public="1" set="null" static="1">
		<x path="vscode.OverviewRulerLane"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Center>
	<Right public="1" set="null" static="1">
		<x path="vscode.OverviewRulerLane"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Right>
	<Full public="1" set="null" static="1">
		<x path="vscode.OverviewRulerLane"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Full>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"OverviewRulerLane"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._OverviewRulerLane.OverviewRulerLane_Impl_" params="" file="src/vscode/OverviewRulerLane.hx" private="1" module="vscode.OverviewRulerLane" extern="1">
		<Left public="1" set="null" static="1">
			<x path="vscode.OverviewRulerLane"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Left>
		<Center public="1" set="null" static="1">
			<x path="vscode.OverviewRulerLane"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Center>
		<Right public="1" set="null" static="1">
			<x path="vscode.OverviewRulerLane"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Right>
		<Full public="1" set="null" static="1">
			<x path="vscode.OverviewRulerLane"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Full>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"OverviewRulerLane"</e>
			</m>
		</meta>
	</class>
	<class path="vscode.ParameterInformation" params="" file="src/vscode/ParameterInformation.hx" extern="1">
		<label public="1">
			<c path="String"/>
			<haxe_doc>* The label of this signature. Will be shown in
	 * the UI.</haxe_doc>
		</label>
		<documentation public="1">
			<c path="String"/>
			<haxe_doc>* The human-readable doc-comment of this signature. Will be shown
	 * in the UI but can be omitted.</haxe_doc>
		</documentation>
		<new public="1" set="method">
			<f a="label:?documentation">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new parameter information object.
	 *
	 * @param label A label string.
	 * @param documentation A doc string.</haxe_doc>
		</new>
		<haxe_doc>* Represents a parameter of a callable-signature. A parameter can
 * have a label and a doc-comment.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"ParameterInformation"</e>
</m></meta>
	</class>
	<class path="vscode.Position" params="" file="src/vscode/Position.hx" extern="1">
		<line public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The zero-based line value.
	 * @readonly</haxe_doc>
		</line>
		<character public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The zero-based character value.
	 * @readonly</haxe_doc>
		</character>
		<isBefore public="1" set="method">
			<f a="other">
				<c path="vscode.Position"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if `other` is before this position.
	 *
	 * @param other A position.
	 * @return `true` if position is on a smaller line
	 * or on the same line on a smaller character.</haxe_doc>
		</isBefore>
		<isBeforeOrEqual public="1" set="method">
			<f a="other">
				<c path="vscode.Position"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if `other` is before or equal to this position.
	 *
	 * @param other A position.
	 * @return `true` if position is on a smaller line
	 * or on the same line on a smaller or equal character.</haxe_doc>
		</isBeforeOrEqual>
		<isAfter public="1" set="method">
			<f a="other">
				<c path="vscode.Position"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if `other` is after this position.
	 *
	 * @param other A position.
	 * @return `true` if position is on a greater line
	 * or on the same line on a greater character.</haxe_doc>
		</isAfter>
		<isAfterOrEqual public="1" set="method">
			<f a="other">
				<c path="vscode.Position"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if `other` is after or equal to this position.
	 *
	 * @param other A position.
	 * @return `true` if position is on a greater line
	 * or on the same line on a greater or equal character.</haxe_doc>
		</isAfterOrEqual>
		<isEqual public="1" set="method">
			<f a="other">
				<c path="vscode.Position"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if `other` equals this position.
	 *
	 * @param other A position.
	 * @return `true` if the line and character of the given position are equal to
	 * the line and character of this position.</haxe_doc>
		</isEqual>
		<compareTo public="1" set="method">
			<f a="other">
				<c path="vscode.Position"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Compare this to `other`.
	 *
	 * @param other A position.
	 * @return A number smaller than zero if this position is before the given position,
	 * a number greater than zero if this position is after the given position, or zero when
	 * this and the given position are equal.</haxe_doc>
		</compareTo>
		<translate public="1" set="method">
			<f a="?lineDelta:?characterDelta">
				<x path="Int"/>
				<x path="Int"/>
				<c path="vscode.Position"/>
			</f>
			<haxe_doc>* Create a new position relative to this position.
	 *
	 * @param lineDelta Delta value for the line value, default is `0`.
	 * @param characterDelta Delta value for the character value, default is `0`.
	 * @return A position which line and character is the sum of the current line and
	 * character and the corresponding deltas.</haxe_doc>
			<overloads><translate public="1" set="method">
	<f a="change">
		<a>
			<lineDelta>
				<t path="Null"><x path="Int"/></t>
				<meta><m n=":optional"/></meta>
			</lineDelta>
			<characterDelta>
				<t path="Null"><x path="Int"/></t>
				<meta><m n=":optional"/></meta>
			</characterDelta>
		</a>
		<c path="vscode.Position"/>
	</f>
	<haxe_doc>* Create a new position relative to this position.
	 *
	 * @param lineDelta Delta value for the line value, default is `0`.
	 * @param characterDelta Delta value for the character value, default is `0`.
	 * @return A position which line and character is the sum of the current line and
	 * character and the corresponding deltas.</haxe_doc>
</translate></overloads>
		</translate>
		<with public="1" set="method">
			<f a="?line:?character">
				<x path="Int"/>
				<x path="Int"/>
				<c path="vscode.Position"/>
			</f>
			<haxe_doc>* Create a new position derived from this position.
	 *
	 * @param line Value that should be used as line value, default is the [existing value](#Position.line)
	 * @param character Value that should be used as character value, default is the [existing value](#Position.character)
	 * @return A position where line and character are replaced by the given values.</haxe_doc>
			<overloads><with public="1" set="method">
	<f a="change">
		<a>
			<line>
				<t path="Null"><x path="Int"/></t>
				<meta><m n=":optional"/></meta>
			</line>
			<character>
				<t path="Null"><x path="Int"/></t>
				<meta><m n=":optional"/></meta>
			</character>
		</a>
		<c path="vscode.Position"/>
	</f>
	<haxe_doc>* Create a new position derived from this position.
	 *
	 * @param line Value that should be used as line value, default is the [existing value](#Position.line)
	 * @param character Value that should be used as character value, default is the [existing value](#Position.character)
	 * @return A position where line and character are replaced by the given values.</haxe_doc>
</with></overloads>
		</with>
		<new public="1" set="method">
			<f a="line:character">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* @param line A zero-based line value.
	 * @param character A zero-based character value.</haxe_doc>
		</new>
		<haxe_doc>* Represents a line and character position, such as
 * the position of the cursor.
 *
 * Position objects are __immutable__. Use the [with](#Position.with) or
 * [translate](#Position.translate) methods to derive new positions
 * from an existing position.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"Position"</e>
</m></meta>
	</class>
	<typedef path="vscode.QuickPickItem" params="" file="src/vscode/QuickPickItem.hx">
		<a>
			<label>
				<c path="String"/>
				<haxe_doc>* A human readable string which is rendered prominent.</haxe_doc>
			</label>
			<detail>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* A human readable string which is rendered less prominent.</haxe_doc>
			</detail>
			<description>
				<c path="String"/>
				<haxe_doc>* A human readable string which is rendered less prominent.</haxe_doc>
			</description>
		</a>
		<haxe_doc>* Represents an item that can be selected from
 * a list of items.</haxe_doc>
	</typedef>
	<typedef path="vscode.QuickPickOptions" params="" file="src/vscode/QuickPickOptions.hx">
		<a>
			<placeHolder>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* An optional string to show as place holder in the input box to guide the user what to pick on.</haxe_doc>
			</placeHolder>
			<onDidSelectItem>
				<t path="Null"><f a="">
	<x path="haxe.extern.EitherType">
		<t path="vscode.QuickPickItem"/>
		<c path="String"/>
	</x>
	<x path="Any"/>
</f></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* An optional function that is invoked whenever an item is selected.</haxe_doc>
			</onDidSelectItem>
			<matchOnDetail>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* An optional flag to include the detail when filtering the picks.</haxe_doc>
			</matchOnDetail>
			<matchOnDescription>
				<t path="Null"><x path="Bool"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* An optional flag to include the description when filtering the picks.</haxe_doc>
			</matchOnDescription>
		</a>
		<haxe_doc>* Options to configure the behavior of the quick pick UI.</haxe_doc>
	</typedef>
	<class path="vscode.Range" params="" file="src/vscode/Range.hx" extern="1">
		<start public="1" set="null">
			<c path="vscode.Position"/>
			<haxe_doc>* The start position. It is before or equal to [end](#Range.end).
	 * @readonly</haxe_doc>
		</start>
		<end public="1" set="null">
			<c path="vscode.Position"/>
			<haxe_doc>* The end position. It is after or equal to [start](#Range.start).
	 * @readonly</haxe_doc>
		</end>
		<isEmpty public="1">
			<x path="Bool"/>
			<haxe_doc>* `true` iff `start` and `end` are equal.</haxe_doc>
		</isEmpty>
		<isSingleLine public="1">
			<x path="Bool"/>
			<haxe_doc>* `true` iff `start.line` and `end.line` are equal.</haxe_doc>
		</isSingleLine>
		<contains public="1" set="method">
			<f a="positionOrRange">
				<x path="haxe.extern.EitherType">
					<c path="vscode.Position"/>
					<c path="vscode.Range"/>
				</x>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if a position or a range is contained in this range.
	 *
	 * @param positionOrRange A position or a range.
	 * @return `true` iff the position or range is inside or equal
	 * to this range.</haxe_doc>
		</contains>
		<isEqual public="1" set="method">
			<f a="other">
				<c path="vscode.Range"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if `other` equals this range.
	 *
	 * @param other A range.
	 * @return `true` when start and end are [equal](#Position.isEqual) to
	 * start and end of this range.</haxe_doc>
		</isEqual>
		<intersection public="1" set="method">
			<f a="range">
				<c path="vscode.Range"/>
				<c path="vscode.Range"/>
			</f>
			<haxe_doc>* Intersect `range` with this range and returns a new range or `undefined`
	 * if the ranges have no overlap.
	 *
	 * @param range A range.
	 * @return A range of the greater start and smaller end positions. Will
	 * return undefined when there is no overlap.</haxe_doc>
		</intersection>
		<union public="1" set="method">
			<f a="other">
				<c path="vscode.Range"/>
				<c path="vscode.Range"/>
			</f>
			<haxe_doc>* Compute the union of `other` with this range.
	 *
	 * @param other A range.
	 * @return A range of smaller start position and the greater end position.</haxe_doc>
		</union>
		<with public="1" set="method">
			<f a="?start:?end">
				<c path="vscode.Position"/>
				<c path="vscode.Position"/>
				<c path="vscode.Range"/>
			</f>
			<haxe_doc>* Derived a new range from this range.
	 *
	 * @param start A position that should be used as start. The default value is the [current start](#Range.start).
	 * @param end A position that should be used as end. The default value is the [current end](#Range.end).
	 * @return A range derived from this range with the given start and end position.
	 * If start and end are not different `this` range will be returned.</haxe_doc>
			<overloads><with public="1" set="method">
	<f a="change">
		<a>
			<start>
				<t path="Null"><c path="vscode.Position"/></t>
				<meta><m n=":optional"/></meta>
			</start>
			<end>
				<t path="Null"><c path="vscode.Position"/></t>
				<meta><m n=":optional"/></meta>
			</end>
		</a>
		<c path="vscode.Range"/>
	</f>
	<haxe_doc>* Derived a new range from this range.
	 *
	 * @param start A position that should be used as start. The default value is the [current start](#Range.start).
	 * @param end A position that should be used as end. The default value is the [current end](#Range.end).
	 * @return A range derived from this range with the given start and end position.
	 * If start and end are not different `this` range will be returned.</haxe_doc>
</with></overloads>
		</with>
		<new public="1" set="method">
			<f a="start:end">
				<c path="vscode.Position"/>
				<c path="vscode.Position"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new range from two positions. If `start` is not
	 * before or equal to `end`, the values will be swapped.
	 *
	 * @param start A position.
	 * @param end A position.</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="startLine:startCharacter:endLine:endCharacter">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* Create a new range from two positions. If `start` is not
	 * before or equal to `end`, the values will be swapped.
	 *
	 * @param start A position.
	 * @param end A position.</haxe_doc>
</new></overloads>
		</new>
		<haxe_doc>* A range represents an ordered pair of two positions.
 * It is guaranteed that [start](#Range.start).isBeforeOrEqual([end](#Range.end))
 *
 * Range objects are __immutable__. Use the [with](#Range.with),
 * [intersection](#Range.intersection), or [union](#Range.union) methods
 * to derive new ranges from an existing range.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"Range"</e>
</m></meta>
	</class>
	<typedef path="vscode.ReferenceContext" params="" file="src/vscode/ReferenceContext.hx">
		<a><includeDeclaration>
	<x path="Bool"/>
	<haxe_doc>* Include the declaration of the current symbol.</haxe_doc>
</includeDeclaration></a>
		<haxe_doc>* Value-object that contains additional information when
 * requesting references.</haxe_doc>
	</typedef>
	<typedef path="vscode.ReferenceProvider" params="" file="src/vscode/ReferenceProvider.hx">
		<a><provideReferences set="method">
	<f a="document:position:context:token">
		<t path="vscode.TextDocument"/>
		<c path="vscode.Position"/>
		<t path="vscode.ReferenceContext"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="Array"><c path="vscode.Location"/></c>
			<t path="js.Thenable"><c path="Array"><c path="vscode.Location"/></c></t>
		</x>
	</f>
	<haxe_doc>* Provide a set of project-wide references for the given position and document.
	 *
	 * @param document The document in which the command was invoked.
	 * @param position The position at which the command was invoked.
	 * @param context
	 * @param token A cancellation token.
	 * @return An array of locations or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
</provideReferences></a>
		<haxe_doc>* The reference provider interface defines the contract between extensions and
 * the [find references](https://code.visualstudio.com/docs/editor/editingevolved#_peek)-feature.</haxe_doc>
	</typedef>
	<typedef path="vscode.RenameProvider" params="" file="src/vscode/RenameProvider.hx">
		<a><provideRenameEdits set="method">
	<f a="document:position:newName:token">
		<t path="vscode.TextDocument"/>
		<c path="vscode.Position"/>
		<c path="String"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="vscode.WorkspaceEdit"/>
			<t path="js.Thenable"><c path="vscode.WorkspaceEdit"/></t>
		</x>
	</f>
	<haxe_doc>* Provide an edit that describes changes that have to be made to one
	 * or many resources to rename a symbol to a different name.
	 *
	 * @param document The document in which the command was invoked.
	 * @param position The position at which the command was invoked.
	 * @param newName The new name of the symbol. If the given name is not valid, the provider must return a rejected promise.
	 * @param token A cancellation token.
	 * @return A workspace edit or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined` or `null`.</haxe_doc>
</provideRenameEdits></a>
		<haxe_doc>* The rename provider interface defines the contract between extensions and
 * the [rename](https://code.visualstudio.com/docs/editor/editingevolved#_rename-symbol)-feature.</haxe_doc>
	</typedef>
	<class path="vscode.Selection" params="" file="src/vscode/Selection.hx" extern="1">
		<extends path="vscode.Range"/>
		<anchor public="1">
			<c path="vscode.Position"/>
			<haxe_doc>* The position at which the selection starts.
	 * This position might be before or after [active](#Selection.active).</haxe_doc>
		</anchor>
		<active public="1">
			<c path="vscode.Position"/>
			<haxe_doc>* The position of the cursor.
	 * This position might be before or after [anchor](#Selection.anchor).</haxe_doc>
		</active>
		<isReversed public="1">
			<x path="Bool"/>
			<haxe_doc>* A selection is reversed if [active](#Selection.active).isBefore([anchor](#Selection.anchor)).</haxe_doc>
		</isReversed>
		<new public="1" set="method">
			<f a="anchor:active">
				<c path="vscode.Position"/>
				<c path="vscode.Position"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a selection from two postions.
	 *
	 * @param anchor A position.
	 * @param active A position.</haxe_doc>
			<overloads><new public="1" set="method">
	<f a="anchorLine:anchorCharacter:activeLine:activeCharacter">
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Int"/>
		<x path="Void"/>
	</f>
	<haxe_doc>* Create a selection from two postions.
	 *
	 * @param anchor A position.
	 * @param active A position.</haxe_doc>
</new></overloads>
		</new>
		<haxe_doc>* Represents a text selection in an editor.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"Selection"</e>
</m></meta>
	</class>
	<class path="vscode.SignatureHelp" params="" file="src/vscode/SignatureHelp.hx" extern="1">
		<signatures public="1">
			<c path="Array"><c path="vscode.SignatureInformation"/></c>
			<haxe_doc>* One or more signatures.</haxe_doc>
		</signatures>
		<activeSignature public="1">
			<x path="Int"/>
			<haxe_doc>* The active signature.</haxe_doc>
		</activeSignature>
		<activeParameter public="1">
			<x path="Int"/>
			<haxe_doc>* The active parameter of the active signature.</haxe_doc>
		</activeParameter>
		<haxe_doc>* Signature help represents the signature of something
 * callable. There can be multiple signatures but only one
 * active and only one active parameter.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"SignatureHelp"</e>
</m></meta>
	</class>
	<typedef path="vscode.SignatureHelpProvider" params="" file="src/vscode/SignatureHelpProvider.hx">
		<a><provideSignatureHelp set="method">
	<f a="document:position:token">
		<t path="vscode.TextDocument"/>
		<c path="vscode.Position"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="vscode.SignatureHelp"/>
			<t path="js.Thenable"><c path="vscode.SignatureHelp"/></t>
		</x>
	</f>
	<haxe_doc>* Provide help for the signature at the given position and document.
	 *
	 * @param document The document in which the command was invoked.
	 * @param position The position at which the command was invoked.
	 * @param token A cancellation token.
	 * @return Signature help or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined` or `null`.</haxe_doc>
</provideSignatureHelp></a>
		<haxe_doc>* The signature help provider interface defines the contract between extensions and
 * the [parameter hints](https://code.visualstudio.com/docs/editor/editingevolved#_parameter-hints)-feature.</haxe_doc>
	</typedef>
	<class path="vscode.SignatureInformation" params="" file="src/vscode/SignatureInformation.hx" extern="1">
		<label public="1">
			<c path="String"/>
			<haxe_doc>* The label of this signature. Will be shown in
	 * the UI.</haxe_doc>
		</label>
		<documentation public="1">
			<c path="String"/>
			<haxe_doc>* The human-readable doc-comment of this signature. Will be shown
	 * in the UI but can be omitted.</haxe_doc>
		</documentation>
		<parameters public="1">
			<c path="Array"><c path="vscode.ParameterInformation"/></c>
			<haxe_doc>* The parameters of this signature.</haxe_doc>
		</parameters>
		<new public="1" set="method">
			<f a="label:?documentation">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new signature information object.
	 *
	 * @param label A label string.
	 * @param documentation A doc string.</haxe_doc>
		</new>
		<haxe_doc>* Represents the signature of something callable. A signature
 * can have a label, like a function-name, a doc-comment, and
 * a set of parameters.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"SignatureInformation"</e>
</m></meta>
	</class>
	<abstract path="vscode.StatusBarAlignment" params="" file="src/vscode/StatusBarAlignment.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Represents the alignment of status bar items.</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"StatusBarAlignment"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._StatusBarAlignment.StatusBarAlignment_Impl_" params="" file="src/vscode/StatusBarAlignment.hx" private="1" module="vscode.StatusBarAlignment" extern="1">
	<Left public="1" set="null" static="1">
		<x path="vscode.StatusBarAlignment"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Aligned to the left side.</haxe_doc>
	</Left>
	<Right public="1" set="null" static="1">
		<x path="vscode.StatusBarAlignment"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Aligned to the right side.</haxe_doc>
	</Right>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"StatusBarAlignment"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._StatusBarAlignment.StatusBarAlignment_Impl_" params="" file="src/vscode/StatusBarAlignment.hx" private="1" module="vscode.StatusBarAlignment" extern="1">
		<Left public="1" set="null" static="1">
			<x path="vscode.StatusBarAlignment"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Aligned to the left side.</haxe_doc>
		</Left>
		<Right public="1" set="null" static="1">
			<x path="vscode.StatusBarAlignment"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Aligned to the right side.</haxe_doc>
		</Right>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"StatusBarAlignment"</e>
			</m>
		</meta>
	</class>
	<typedef path="vscode.StatusBarItem" params="" file="src/vscode/StatusBarItem.hx">
		<a>
			<tooltip>
				<c path="String"/>
				<haxe_doc>* The tooltip text when you hover over this entry.</haxe_doc>
			</tooltip>
			<text>
				<c path="String"/>
				<haxe_doc>* The text to show for the entry. You can embed icons in the text by leveraging the syntax:
	 *
	 * `My text $(icon-name) contains icons like $(icon'name) this one.`
	 *
	 * Where the icon-name is taken from the [octicon](https://octicons.github.com) icon set, e.g.
	 * `light-bulb`, `thumbsup`, `zap` etc.</haxe_doc>
			</text>
			<show set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>* Shows the entry in the status bar.</haxe_doc>
			</show>
			<priority set="null">
				<x path="Float"/>
				<haxe_doc>* The priority of this item. Higher value means the item should
	 * be shown more to the left.
	 *
	 * @readonly</haxe_doc>
			</priority>
			<hide set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>* Hide the entry in the status bar.</haxe_doc>
			</hide>
			<dispose set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>* Dispose and free associated resources. Call
	 * [hide](#StatusBarItem.hide).</haxe_doc>
			</dispose>
			<command>
				<c path="String"/>
				<haxe_doc>* The identifier of a command to run on click. The command must be
	 * [known](#commands.getCommands).</haxe_doc>
			</command>
			<color>
				<c path="String"/>
				<haxe_doc>* The foreground color for this entry.</haxe_doc>
			</color>
			<alignment set="null">
				<x path="vscode.StatusBarAlignment"/>
				<haxe_doc>* The alignment of this item.
	 *
	 * @readonly</haxe_doc>
			</alignment>
		</a>
		<haxe_doc>* A status bar item is a status bar contribution that can
 * show text and icons and run a command on click.</haxe_doc>
	</typedef>
	<class path="vscode.SymbolInformation" params="" file="src/vscode/SymbolInformation.hx" extern="1">
		<name public="1">
			<c path="String"/>
			<haxe_doc>* The name of this symbol.</haxe_doc>
		</name>
		<containerName public="1">
			<c path="String"/>
			<haxe_doc>* The name of the symbol containing this symbol.</haxe_doc>
		</containerName>
		<kind public="1">
			<x path="vscode.SymbolKind"/>
			<haxe_doc>* The kind of this symbol.</haxe_doc>
		</kind>
		<location public="1">
			<c path="vscode.Location"/>
			<haxe_doc>* The location of this symbol.</haxe_doc>
		</location>
		<new public="1" set="method">
			<f a="name:kind:range:?uri:?containerName">
				<c path="String"/>
				<x path="vscode.SymbolKind"/>
				<c path="vscode.Range"/>
				<c path="vscode.Uri"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new symbol information object.
	 *
	 * @param name The name of the symbol.
	 * @param kind The kind of the symbol.
	 * @param range The range of the location of the symbol.
	 * @param uri The resource of the location of symbol, defaults to the current document.
	 * @param containerName The name of the symbol containing the symbol.</haxe_doc>
		</new>
		<haxe_doc>* Represents information about programming constructs like variables, classes,
 * interfaces etc.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"SymbolInformation"</e>
</m></meta>
	</class>
	<abstract path="vscode.SymbolKind" params="" file="src/vscode/SymbolKind.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* A symbol kind.</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"SymbolKind"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._SymbolKind.SymbolKind_Impl_" params="" file="src/vscode/SymbolKind.hx" private="1" module="vscode.SymbolKind" extern="1">
	<File public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</File>
	<Module public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Module>
	<Namespace public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Namespace>
	<Package public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Package>
	<Class public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Class>
	<Method public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Method>
	<Property public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Property>
	<Field public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Field>
	<Constructor public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Constructor>
	<Enum public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Enum>
	<Interface public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Interface>
	<Function public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Function>
	<Variable public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Variable>
	<Constant public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Constant>
	<String public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</String>
	<Number public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Number>
	<Boolean public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Boolean>
	<Array public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Array>
	<Object public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Object>
	<Key public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Key>
	<Null public="1" set="null" static="1">
		<x path="vscode.SymbolKind"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Null>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"SymbolKind"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._SymbolKind.SymbolKind_Impl_" params="" file="src/vscode/SymbolKind.hx" private="1" module="vscode.SymbolKind" extern="1">
		<File public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</File>
		<Module public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Module>
		<Namespace public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Namespace>
		<Package public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Package>
		<Class public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Class>
		<Method public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Method>
		<Property public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Property>
		<Field public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Field>
		<Constructor public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Constructor>
		<Enum public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Enum>
		<Interface public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Interface>
		<Function public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Function>
		<Variable public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Variable>
		<Constant public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Constant>
		<String public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</String>
		<Number public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Number>
		<Boolean public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Boolean>
		<Array public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Array>
		<Object public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Object>
		<Key public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Key>
		<Null public="1" set="null" static="1">
			<x path="vscode.SymbolKind"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Null>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"SymbolKind"</e>
			</m>
		</meta>
	</class>
	<typedef path="vscode.TextDocument" params="" file="src/vscode/TextDocument.hx">
		<a>
			<version set="null">
				<x path="Int"/>
				<haxe_doc>* The version number of this document (it will strictly increase after each
	 * change, including undo/redo).
	 *
	 * @readonly</haxe_doc>
			</version>
			<validateRange set="method">
				<f a="range">
					<c path="vscode.Range"/>
					<c path="vscode.Range"/>
				</f>
				<haxe_doc>* Ensure a range is completely contained in this document.
	 *
	 * @param range A range.
	 * @return The given range or a new, adjusted range.</haxe_doc>
			</validateRange>
			<validatePosition set="method">
				<f a="position">
					<c path="vscode.Position"/>
					<c path="vscode.Position"/>
				</f>
				<haxe_doc>* Ensure a position is contained in the range of this document.
	 *
	 * @param position A position.
	 * @return The given position or a new, adjusted position.</haxe_doc>
			</validatePosition>
			<uri set="null">
				<c path="vscode.Uri"/>
				<haxe_doc>* The associated URI for this document. Most documents have the __file__-scheme, indicating that they
	 * represent files on disk. However, some documents may have other schemes indicating that they are not
	 * available on disk.
	 *
	 * @readonly</haxe_doc>
			</uri>
			<save set="method">
				<f a=""><t path="js.Thenable"><x path="Bool"/></t></f>
				<haxe_doc>* Save the underlying file.
	 *
	 * @return A promise that will resolve to true when the file
	 * has been saved. If the file was not dirty or the save failed,
	 * will return false.</haxe_doc>
			</save>
			<positionAt set="method">
				<f a="offset">
					<x path="Int"/>
					<c path="vscode.Position"/>
				</f>
				<haxe_doc>* Converts a zero-based offset to a position.
	 *
	 * @param offset A zero-based offset.
	 * @return A valid [position](#Position).</haxe_doc>
			</positionAt>
			<offsetAt set="method">
				<f a="position">
					<c path="vscode.Position"/>
					<x path="Int"/>
				</f>
				<haxe_doc>* Converts the position to a zero-based offset.
	 *
	 * The position will be [adjusted](#TextDocument.validatePosition).
	 *
	 * @param position A position.
	 * @return A valid zero-based offset.</haxe_doc>
			</offsetAt>
			<lineCount>
				<x path="Int"/>
				<haxe_doc>* The number of lines in this document.
	 *
	 * @readonly</haxe_doc>
			</lineCount>
			<lineAt set="method">
				<f a="line">
					<x path="Int"/>
					<t path="vscode.TextLine"/>
				</f>
				<haxe_doc>* Returns a text line denoted by the line number. Note
	 * that the returned object is *not* live and changes to the
	 * document are not reflected.
	 *
	 * @param line A line number in [0, lineCount).
	 * @return A [line](#TextLine).</haxe_doc>
				<overloads><lineAt public="1" set="method">
	<f a="position">
		<c path="vscode.Position"/>
		<t path="vscode.TextLine"/>
	</f>
	<haxe_doc>* Returns a text line denoted by the line number. Note
	 * that the returned object is *not* live and changes to the
	 * document are not reflected.
	 *
	 * @param line A line number in [0, lineCount).
	 * @return A [line](#TextLine).</haxe_doc>
</lineAt></overloads>
			</lineAt>
			<languageId set="null">
				<c path="String"/>
				<haxe_doc>* The identifier of the language associated with this document.
	 *
	 * @readonly</haxe_doc>
			</languageId>
			<isUntitled set="null">
				<x path="Bool"/>
				<haxe_doc>* Is this document representing an untitled file.
	 *
	 * @readonly</haxe_doc>
			</isUntitled>
			<isDirty set="null">
				<x path="Bool"/>
				<haxe_doc>* true if there are unpersisted changes.
	 *
	 * @readonly</haxe_doc>
			</isDirty>
			<getWordRangeAtPosition set="method">
				<f a="position">
					<c path="vscode.Position"/>
					<c path="vscode.Range"/>
				</f>
				<haxe_doc>* Get a word-range at the given position. By default words are defined by
	 * common separators, like space, -, _, etc. In addition, per languge custom
	 * [word definitions](#LanguageConfiguration.wordPattern) can be defined.
	 *
	 * The position will be [adjusted](#TextDocument.validatePosition).
	 *
	 * @param position A position.
	 * @return A range spanning a word, or `undefined`.</haxe_doc>
			</getWordRangeAtPosition>
			<getText set="method">
				<f a="?range">
					<c path="vscode.Range"/>
					<c path="String"/>
				</f>
				<haxe_doc>* Get the text of this document. A substring can be retrieved by providing
	 * a range. The range will be [adjusted](#TextDocument.validateRange).
	 *
	 * @param range Include only the text included by the range.
	 * @return The text inside the provided range or the entire text.</haxe_doc>
			</getText>
			<fileName set="null">
				<c path="String"/>
				<haxe_doc>* The file system path of the associated resource. Shorthand
	 * notation for [TextDocument.uri.fsPath](#TextDocument.uri). Independent of the uri scheme.
	 *
	 * @readonly</haxe_doc>
			</fileName>
		</a>
		<haxe_doc>* Represents a text document, such as a source file. Text documents have
 * [lines](#TextLine) and knowledge about an underlying resource like a file.</haxe_doc>
	</typedef>
	<typedef path="vscode.TextDocumentChangeEvent" params="" file="src/vscode/TextDocumentChangeEvent.hx">
		<a>
			<document>
				<t path="vscode.TextDocument"/>
				<haxe_doc>* The affected document.</haxe_doc>
			</document>
			<contentChanges>
				<c path="Array"><t path="vscode.TextDocumentContentChangeEvent"/></c>
				<haxe_doc>* An array of content changes.</haxe_doc>
			</contentChanges>
		</a>
		<haxe_doc>* An event describing a transactional [document](#TextDocument) change.</haxe_doc>
	</typedef>
	<typedef path="vscode.TextDocumentContentChangeEvent" params="" file="src/vscode/TextDocumentContentChangeEvent.hx">
		<a>
			<text>
				<c path="String"/>
				<haxe_doc>* The new text for the range.</haxe_doc>
			</text>
			<rangeLength>
				<x path="Int"/>
				<haxe_doc>* The length of the range that got replaced.</haxe_doc>
			</rangeLength>
			<range>
				<c path="vscode.Range"/>
				<haxe_doc>* The range that got replaced.</haxe_doc>
			</range>
		</a>
		<haxe_doc>* An event describing an individual change in the text of a [document](#TextDocument).</haxe_doc>
	</typedef>
	<typedef path="vscode.TextDocumentContentProvider" params="" file="src/vscode/TextDocumentContentProvider.hx">
		<a>
			<provideTextDocumentContent set="method">
				<f a="uri:token">
					<c path="vscode.Uri"/>
					<t path="vscode.CancellationToken"/>
					<x path="haxe.extern.EitherType">
						<c path="String"/>
						<t path="js.Thenable"><c path="String"/></t>
					</x>
				</f>
				<haxe_doc>* Provide textual content for a given uri.
	 *
	 * The editor will use the returned string-content to create a readonly
	 * [document](TextDocument). Resources allocated should be released when
	 * the corresponding document has been [closed](#workspace.onDidCloseTextDocument).
	 *
	 * @param uri An uri which scheme matches the scheme this provider was [registered](#workspace.registerTextDocumentContentProvider) for.
	 * @param token A cancellation token.
	 * @return A string or a thenable that resolves to such.</haxe_doc>
			</provideTextDocumentContent>
			<onDidChange>
				<t path="Null"><t path="vscode.Event"><c path="vscode.Uri"/></t></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* An event to signal a resource has changed.</haxe_doc>
			</onDidChange>
		</a>
		<haxe_doc>* A text document content provider allows to add readonly documents
 * to the editor, such as source from a dll or generated html from md.
 *
 * Content providers are [registered](#workspace.registerTextDocumentContentProvider)
 * for a [uri-scheme](#Uri.scheme). When a uri with that scheme is to
 * be [loaded](#workspace.openTextDocument) the content provider is
 * asked.</haxe_doc>
	</typedef>
	<class path="vscode.TextEdit" params="" file="src/vscode/TextEdit.hx" extern="1">
		<replace public="1" set="method" static="1">
			<f a="range:newText">
				<c path="vscode.Range"/>
				<c path="String"/>
				<c path="vscode.TextEdit"/>
			</f>
			<haxe_doc>* Utility to create a replace edit.
	 *
	 * @param range A range.
	 * @param newText A string.
	 * @return A new text edit object.</haxe_doc>
		</replace>
		<insert public="1" set="method" static="1">
			<f a="position:newText">
				<c path="vscode.Position"/>
				<c path="String"/>
				<c path="vscode.TextEdit"/>
			</f>
			<haxe_doc>* Utility to create an insert edit.
	 *
	 * @param position A position, will become an empty range.
	 * @param newText A string.
	 * @return A new text edit object.</haxe_doc>
		</insert>
		<delete public="1" set="method" static="1">
			<f a="range">
				<c path="vscode.Range"/>
				<c path="vscode.TextEdit"/>
			</f>
			<haxe_doc>* Utility to create a delete edit.
	 *
	 * @param range A range.
	 * @return A new text edit object.</haxe_doc>
		</delete>
		<range public="1">
			<c path="vscode.Range"/>
			<haxe_doc>* The range this edit applies to.</haxe_doc>
		</range>
		<newText public="1">
			<c path="String"/>
			<haxe_doc>* The string this edit will insert.</haxe_doc>
		</newText>
		<new public="1" set="method">
			<f a="range:newText">
				<c path="vscode.Range"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Create a new TextEdit.
	 *
	 * @param range A range.
	 * @param newText A string.</haxe_doc>
		</new>
		<haxe_doc>* A text edit represents edits that should be applied
 * to a document.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"TextEdit"</e>
</m></meta>
	</class>
	<typedef path="vscode.TextEditor" params="" file="src/vscode/TextEditor.hx">
		<a>
			<viewColumn>
				<x path="vscode.ViewColumn"/>
				<haxe_doc>* The column in which this editor shows. Will be `undefined` in case this
	 * isn't one of the three main editors, e.g an embedded editor.</haxe_doc>
			</viewColumn>
			<show set="method">
				<f a="?column">
					<x path="vscode.ViewColumn"/>
					<x path="Void"/>
				</f>
				<meta><m n=":deprecated"><e>"Use [window.showTextDocument](#window.showTextDocument) instead."</e></m></meta>
				<haxe_doc>* Show the text editor.
	 *
	 * @deprecated **This method is deprecated.** Use [window.showTextDocument](#window.showTextDocument)
	 * instead. This method shows unexpected behavior and will be removed in the next major update.
	 *
	 * @param column The [column](#ViewColumn) in which to show this editor.</haxe_doc>
			</show>
			<setDecorations set="method">
				<f a="decorationType:rangesOrOptions">
					<t path="vscode.TextEditorDecorationType"/>
					<x path="haxe.extern.EitherType">
						<c path="Array"><c path="vscode.Range"/></c>
						<c path="Array"><t path="vscode.DecorationOptions"/></c>
					</x>
					<x path="Void"/>
				</f>
				<haxe_doc>* Adds a set of decorations to the text editor. If a set of decorations already exists with
	 * the given [decoration type](#TextEditorDecorationType), they will be replaced.
	 *
	 * @see [createTextEditorDecorationType](#window.createTextEditorDecorationType).
	 *
	 * @param decorationType A decoration type.
	 * @param rangesOrOptions Either [ranges](#Range) or more detailed [options](#DecorationOptions).</haxe_doc>
			</setDecorations>
			<selections>
				<c path="Array"><c path="vscode.Selection"/></c>
				<haxe_doc>* The selections in this text editor. The primary selection is always at index 0.</haxe_doc>
			</selections>
			<selection>
				<c path="vscode.Selection"/>
				<haxe_doc>* The primary selection on this text editor. Shorthand for `TextEditor.selections[0]`.</haxe_doc>
			</selection>
			<revealRange set="method">
				<f a="range:?revealType">
					<c path="vscode.Range"/>
					<x path="vscode.TextEditorRevealType"/>
					<x path="Void"/>
				</f>
				<haxe_doc>* Scroll as indicated by `revealType` in order to reveal the given range.
	 *
	 * @param range A range.
	 * @param revealType The scrolling strategy for revealing `range`.</haxe_doc>
			</revealRange>
			<options>
				<t path="vscode.TextEditorOptions"/>
				<haxe_doc>* Text editor options.</haxe_doc>
			</options>
			<hide set="method">
				<f a=""><x path="Void"/></f>
				<meta><m n=":deprecated"><e>"Use the command 'workbench.action.closeActiveEditor' instead."</e></m></meta>
				<haxe_doc>* Hide the text editor.
	 *
	 * @deprecated **This method is deprecated.** Use the command 'workbench.action.closeActiveEditor' instead.
	 * This method shows unexpected behavior and will be removed in the next major update.</haxe_doc>
			</hide>
			<edit set="method">
				<f a="callback">
					<f a="">
						<t path="vscode.TextEditorEdit"/>
						<x path="Void"/>
					</f>
					<t path="js.Thenable"><x path="Bool"/></t>
				</f>
				<haxe_doc>* Perform an edit on the document associated with this text editor.
	 *
	 * The given callback-function is invoked with an [edit-builder](#TextEditorEdit) which must
	 * be used to make edits. Note that the edit-builder is only valid while the
	 * callback executes.
	 *
	 * @param callback A function which can make edits using an [edit-builder](#TextEditorEdit).
	 * @return A promise that resolves with a value indicating if the edits could be applied.</haxe_doc>
			</edit>
			<document>
				<t path="vscode.TextDocument"/>
				<haxe_doc>* The document associated with this text editor. The document will be the same for the entire lifetime of this text editor.</haxe_doc>
			</document>
		</a>
		<haxe_doc>* Represents an editor that is attached to a [document](#TextDocument).</haxe_doc>
	</typedef>
	<abstract path="vscode.TextEditorCursorStyle" params="" file="src/vscode/TextEditorCursorStyle.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Rendering style of the cursor.</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"TextEditorCursorStyle"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._TextEditorCursorStyle.TextEditorCursorStyle_Impl_" params="" file="src/vscode/TextEditorCursorStyle.hx" private="1" module="vscode.TextEditorCursorStyle" extern="1">
	<Line public="1" set="null" static="1">
		<x path="vscode.TextEditorCursorStyle"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Render the cursor as a vertical line.</haxe_doc>
	</Line>
	<Block public="1" set="null" static="1">
		<x path="vscode.TextEditorCursorStyle"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Render the cursor as a block.</haxe_doc>
	</Block>
	<Underline public="1" set="null" static="1">
		<x path="vscode.TextEditorCursorStyle"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* Render the cursor as a horizontal line under the character.</haxe_doc>
	</Underline>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"TextEditorCursorStyle"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._TextEditorCursorStyle.TextEditorCursorStyle_Impl_" params="" file="src/vscode/TextEditorCursorStyle.hx" private="1" module="vscode.TextEditorCursorStyle" extern="1">
		<Line public="1" set="null" static="1">
			<x path="vscode.TextEditorCursorStyle"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Render the cursor as a vertical line.</haxe_doc>
		</Line>
		<Block public="1" set="null" static="1">
			<x path="vscode.TextEditorCursorStyle"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Render the cursor as a block.</haxe_doc>
		</Block>
		<Underline public="1" set="null" static="1">
			<x path="vscode.TextEditorCursorStyle"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* Render the cursor as a horizontal line under the character.</haxe_doc>
		</Underline>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"TextEditorCursorStyle"</e>
			</m>
		</meta>
	</class>
	<typedef path="vscode.TextEditorDecorationType" params="" file="src/vscode/TextEditorDecorationType.hx">
		<a>
			<key set="null">
				<c path="String"/>
				<haxe_doc>* Internal representation of the handle.
	 * @readonly</haxe_doc>
			</key>
			<dispose set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>* Remove this decoration type and all decorations on all text editors using it.</haxe_doc>
			</dispose>
		</a>
		<haxe_doc>* Represents a handle to a set of decorations
 * sharing the same [styling options](#DecorationRenderOptions) in a [text editor](#TextEditor).
 *
 * To get an instance of a `TextEditorDecorationType` use
 * [createTextEditorDecorationType](#window.createTextEditorDecorationType).</haxe_doc>
	</typedef>
	<typedef path="vscode.TextEditorEdit" params="" file="src/vscode/TextEditorEdit.hx">
		<a>
			<setEndOfLine set="method">
				<f a="endOfLine">
					<x path="vscode.EndOfLine"/>
					<x path="Void"/>
				</f>
				<haxe_doc>* Set the end of line sequence.
	 *
	 * @param endOfLine The new end of line for the [document](#TextDocument).</haxe_doc>
			</setEndOfLine>
			<replace set="method">
				<f a="location:value">
					<x path="haxe.extern.EitherType">
						<c path="vscode.Position"/>
						<x path="haxe.extern.EitherType">
							<c path="vscode.Range"/>
							<c path="vscode.Selection"/>
						</x>
					</x>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>* Replace a certain text region with a new value.
	 * You can use \r\n or \n in `value` and they will be normalized to the current [document](#TextDocument).
	 *
	 * @param location The range this operation should remove.
	 * @param value The new text this operation should insert after removing `location`.</haxe_doc>
			</replace>
			<insert set="method">
				<f a="location:value">
					<c path="vscode.Position"/>
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>* Insert text at a location.
	 * You can use \r\n or \n in `value` and they will be normalized to the current [document](#TextDocument).
	 * Although the equivalent text edit can be made with [replace](#TextEditorEdit.replace), `insert` will produce a different resulting selection (it will get moved).
	 *
	 * @param location The position where the new text should be inserted.
	 * @param value The new text this operation should insert.</haxe_doc>
			</insert>
			<delete set="method">
				<f a="location">
					<x path="haxe.extern.EitherType">
						<c path="vscode.Range"/>
						<c path="vscode.Selection"/>
					</x>
					<x path="Void"/>
				</f>
				<haxe_doc>* Delete a certain text region.
	 *
	 * @param location The range this operation should remove.</haxe_doc>
			</delete>
		</a>
		<haxe_doc>* A complex edit that will be applied in one transaction on a TextEditor.
 * This holds a description of the edits and if the edits are valid (i.e. no overlapping regions, document was not changed in the meantime, etc.)
 * they can be applied on a [document](#TextDocument) associated with a [text editor](#TextEditor).
 *</haxe_doc>
	</typedef>
	<typedef path="vscode.TextEditorOptions" params="" file="src/vscode/TextEditorOptions.hx">
		<a>
			<tabSize>
				<t path="Null"><x path="haxe.extern.EitherType">
	<x path="Int"/>
	<c path="String"/>
</x></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The size in spaces a tab takes. This is used for two purposes:
	 *  - the rendering width of a tab character;
	 *  - the number of spaces to insert when [insertSpaces](#TextEditorOptions.insertSpaces) is true.
	 *
	 * When getting a text editor's options, this property will always be a number (resolved).
	 * When setting a text editor's options, this property is optional and it can be a number or `"auto"`.</haxe_doc>
			</tabSize>
			<insertSpaces>
				<t path="Null"><x path="haxe.extern.EitherType">
	<x path="Bool"/>
	<c path="String"/>
</x></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* When pressing Tab insert [n](#TextEditorOptions.tabSize) spaces.
	 * When getting a text editor's options, this property will always be a boolean (resolved).
	 * When setting a text editor's options, this property is optional and it can be a boolean or `"auto"`.</haxe_doc>
			</insertSpaces>
			<cursorStyle>
				<t path="Null"><x path="vscode.TextEditorCursorStyle"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The rendering style of the cursor in this editor.
	 * When getting a text editor's options, this property will always be present.
	 * When setting a text editor's options, this property is optional.</haxe_doc>
			</cursorStyle>
		</a>
		<haxe_doc>* Represents a [text editor](#TextEditor)'s [options](#TextEditor.options).</haxe_doc>
	</typedef>
	<typedef path="vscode.TextEditorOptionsChangeEvent" params="" file="src/vscode/TextEditorOptionsChangeEvent.hx">
		<a>
			<textEditor>
				<t path="vscode.TextEditor"/>
				<haxe_doc>* The [text editor](#TextEditor) for which the options have changed.</haxe_doc>
			</textEditor>
			<options>
				<t path="vscode.TextEditorOptions"/>
				<haxe_doc>* The new value for the [text editor's options](#TextEditor.options).</haxe_doc>
			</options>
		</a>
		<haxe_doc>* Represents an event describing the change in a [text editor's options](#TextEditor.options).</haxe_doc>
	</typedef>
	<abstract path="vscode.TextEditorRevealType" params="" file="src/vscode/TextEditorRevealType.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Represents different [reveal](#TextEditor.revealRange) strategies in a text editor.</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"TextEditorRevealType"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._TextEditorRevealType.TextEditorRevealType_Impl_" params="" file="src/vscode/TextEditorRevealType.hx" private="1" module="vscode.TextEditorRevealType" extern="1">
	<Default public="1" set="null" static="1">
		<x path="vscode.TextEditorRevealType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* The range will be revealed with as little scrolling as possible.</haxe_doc>
	</Default>
	<InCenter public="1" set="null" static="1">
		<x path="vscode.TextEditorRevealType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* The range will always be revealed in the center of the viewport.</haxe_doc>
	</InCenter>
	<InCenterIfOutsideViewport public="1" set="null" static="1">
		<x path="vscode.TextEditorRevealType"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
		<haxe_doc>* If the range is outside the viewport, it will be revealed in the center of the viewport.
	 * Otherwise, it will be revealed with as little scrolling as possible.</haxe_doc>
	</InCenterIfOutsideViewport>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"TextEditorRevealType"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._TextEditorRevealType.TextEditorRevealType_Impl_" params="" file="src/vscode/TextEditorRevealType.hx" private="1" module="vscode.TextEditorRevealType" extern="1">
		<Default public="1" set="null" static="1">
			<x path="vscode.TextEditorRevealType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* The range will be revealed with as little scrolling as possible.</haxe_doc>
		</Default>
		<InCenter public="1" set="null" static="1">
			<x path="vscode.TextEditorRevealType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* The range will always be revealed in the center of the viewport.</haxe_doc>
		</InCenter>
		<InCenterIfOutsideViewport public="1" set="null" static="1">
			<x path="vscode.TextEditorRevealType"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
			<haxe_doc>* If the range is outside the viewport, it will be revealed in the center of the viewport.
	 * Otherwise, it will be revealed with as little scrolling as possible.</haxe_doc>
		</InCenterIfOutsideViewport>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"TextEditorRevealType"</e>
			</m>
		</meta>
	</class>
	<typedef path="vscode.TextEditorSelectionChangeEvent" params="" file="src/vscode/TextEditorSelectionChangeEvent.hx">
		<a>
			<textEditor>
				<t path="vscode.TextEditor"/>
				<haxe_doc>* The [text editor](#TextEditor) for which the selections have changed.</haxe_doc>
			</textEditor>
			<selections>
				<c path="Array"><c path="vscode.Selection"/></c>
				<haxe_doc>* The new value for the [text editor's selections](#TextEditor.selections).</haxe_doc>
			</selections>
		</a>
		<haxe_doc>* Represents an event describing the change in a [text editor's selections](#TextEditor.selections).</haxe_doc>
	</typedef>
	<typedef path="vscode.TextEditorViewColumnChangeEvent" params="" file="src/vscode/TextEditorViewColumnChangeEvent.hx">
		<a>
			<viewColumn>
				<x path="vscode.ViewColumn"/>
				<haxe_doc>* The new value for the [text editor's view column](#TextEditor.viewColumn).</haxe_doc>
			</viewColumn>
			<textEditor>
				<t path="vscode.TextEditor"/>
				<haxe_doc>* The [text editor](#TextEditor) for which the options have changed.</haxe_doc>
			</textEditor>
		</a>
		<haxe_doc>* Represents an event describing the change of a [text editor's view column](#TextEditor.viewColumn).</haxe_doc>
	</typedef>
	<typedef path="vscode.TextLine" params="" file="src/vscode/TextLine.hx">
		<a>
			<text set="null">
				<c path="String"/>
				<haxe_doc>* The text of this line without the line separator characters.
	 *
	 * @readonly</haxe_doc>
			</text>
			<rangeIncludingLineBreak set="null">
				<c path="vscode.Range"/>
				<haxe_doc>* The range this line covers with the line separator characters.
	 *
	 * @readonly</haxe_doc>
			</rangeIncludingLineBreak>
			<range set="null">
				<c path="vscode.Range"/>
				<haxe_doc>* The range this line covers without the line separator characters.
	 *
	 * @readonly</haxe_doc>
			</range>
			<lineNumber set="null">
				<x path="Int"/>
				<haxe_doc>* The zero-based line number.
	 *
	 * @readonly</haxe_doc>
			</lineNumber>
			<isEmptyOrWhitespace set="null">
				<x path="Bool"/>
				<haxe_doc>* Whether this line is whitespace only, shorthand
	 * for [TextLine.firstNonWhitespaceCharacterIndex](#TextLine.firstNonWhitespaceCharacterIndex) === [TextLine.text.length](#TextLine.text).
	 *
	 * @readonly</haxe_doc>
			</isEmptyOrWhitespace>
			<firstNonWhitespaceCharacterIndex set="null">
				<x path="Int"/>
				<haxe_doc>* The offset of the first character which is not a whitespace character as defined
	 * by `/\s/`. **Note** that if a line is all whitespaces the length of the line is returned.
	 *
	 * @readonly</haxe_doc>
			</firstNonWhitespaceCharacterIndex>
		</a>
		<haxe_doc>* Represents a line of text, such as a line of source code.
 *
 * TextLine objects are __immutable__. When a [document](#TextDocument) changes,
 * previously retrieved lines will not represent the latest state.</haxe_doc>
	</typedef>
	<typedef path="vscode.ThemableDecorationAttachmentRenderOptions" params="" file="src/vscode/ThemableDecorationAttachmentRenderOptions.hx"><a>
	<width>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* CSS styling property that will be applied to the decoration attachment.</haxe_doc>
	</width>
	<textDecoration>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* CSS styling property that will be applied to the decoration attachment.</haxe_doc>
	</textDecoration>
	<margin>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* CSS styling property that will be applied to the decoration attachment.</haxe_doc>
	</margin>
	<height>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* CSS styling property that will be applied to the decoration attachment.</haxe_doc>
	</height>
	<contentText>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Defines a text content that is shown in the attachment. Either an icon or a text can be shown, but not both.</haxe_doc>
	</contentText>
	<contentIconPath>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* An **absolute path** to an image to be rendered in the attachment. Either an icon or a text can be shown, but not both.</haxe_doc>
	</contentIconPath>
	<color>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* CSS styling property that will be applied to the decoration attachment.</haxe_doc>
	</color>
	<border>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* CSS styling property that will be applied to the decoration attachment.</haxe_doc>
	</border>
	<backgroundColor>
		<t path="Null"><c path="String"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* CSS styling property that will be applied to the decoration attachment.</haxe_doc>
	</backgroundColor>
</a></typedef>
	<typedef path="vscode.ThemableDecorationInstanceRenderOptions" params="" file="src/vscode/ThemableDecorationInstanceRenderOptions.hx"><a>
	<before>
		<t path="Null"><t path="vscode.ThemableDecorationAttachmentRenderOptions"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Defines the rendering options of the attachment that is inserted before the decorated text</haxe_doc>
	</before>
	<after>
		<t path="Null"><t path="vscode.ThemableDecorationAttachmentRenderOptions"/></t>
		<meta><m n=":optional"/></meta>
		<haxe_doc>* Defines the rendering options of the attachment that is inserted after the decorated text</haxe_doc>
	</after>
</a></typedef>
	<typedef path="vscode.ThemableDecorationRenderOptions" params="" file="src/vscode/ThemableDecorationRenderOptions.hx">
		<a>
			<textDecoration>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</textDecoration>
			<overviewRulerColor>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* The color of the decoration in the overview ruler. Use rgba() and define transparent colors to play well with other decorations.</haxe_doc>
			</overviewRulerColor>
			<outlineWidth>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'outline' for setting one or more of the individual outline properties.</haxe_doc>
			</outlineWidth>
			<outlineStyle>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'outline' for setting one or more of the individual outline properties.</haxe_doc>
			</outlineStyle>
			<outlineColor>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'outline' for setting one or more of the individual outline properties.</haxe_doc>
			</outlineColor>
			<outline>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</outline>
			<letterSpacing>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</letterSpacing>
			<gutterIconSize>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Specifies the size of the gutter icon.
	 * Available values are 'auto', 'contain', 'cover' and any percentage value.
	 * For further information: https://msdn.microsoft.com/en-us/library/jj127316(v=vs.85).aspx</haxe_doc>
			</gutterIconSize>
			<gutterIconPath>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* An **absolute path** to an image to be rendered in the gutterIconPath.</haxe_doc>
			</gutterIconPath>
			<cursor>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</cursor>
			<color>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</color>
			<borderWidth>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'border' for setting one or more of the individual border properties.</haxe_doc>
			</borderWidth>
			<borderStyle>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'border' for setting one or more of the individual border properties.</haxe_doc>
			</borderStyle>
			<borderSpacing>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'border' for setting one or more of the individual border properties.</haxe_doc>
			</borderSpacing>
			<borderRadius>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'border' for setting one or more of the individual border properties.</haxe_doc>
			</borderRadius>
			<borderColor>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.
	 * Better use 'border' for setting one or more of the individual border properties.</haxe_doc>
			</borderColor>
			<border>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* CSS styling property that will be applied to text enclosed by a decoration.</haxe_doc>
			</border>
			<before>
				<t path="Null"><t path="vscode.ThemableDecorationAttachmentRenderOptions"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Defines the rendering options of the attachment that is inserted before the decorated text</haxe_doc>
			</before>
			<backgroundColor>
				<t path="Null"><c path="String"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Background color of the decoration. Use rgba() and define transparent background colors to play well with other decorations.</haxe_doc>
			</backgroundColor>
			<after>
				<t path="Null"><t path="vscode.ThemableDecorationAttachmentRenderOptions"/></t>
				<meta><m n=":optional"/></meta>
				<haxe_doc>* Defines the rendering options of the attachment that is inserted after the decorated text</haxe_doc>
			</after>
		</a>
		<haxe_doc>* Represents theme specific rendering styles for a [text editor decoration](#TextEditorDecorationType).</haxe_doc>
	</typedef>
	<class path="vscode.Uri" params="" file="src/vscode/Uri.hx" extern="1">
		<file public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="vscode.Uri"/>
			</f>
			<haxe_doc>* Create an URI from a file system path. The [scheme](#Uri.scheme)
	 * will be `file`.
	 *
	 * @param path A file system or UNC path.
	 * @return A new Uri instance.</haxe_doc>
		</file>
		<parse public="1" set="method" static="1">
			<f a="value">
				<c path="String"/>
				<c path="vscode.Uri"/>
			</f>
			<haxe_doc>* Create an URI from a string. Will throw if the given value is not
	 * valid.
	 *
	 * @param value The string value of an Uri.
	 * @return A new Uri instance.</haxe_doc>
		</parse>
		<scheme public="1">
			<c path="String"/>
			<haxe_doc>* Scheme is the `http` part of `http://www.msft.com/some/path?query#fragment`.
	 * The part before the first colon.</haxe_doc>
		</scheme>
		<authority public="1">
			<c path="String"/>
			<haxe_doc>* Authority is the `www.msft.com` part of `http://www.msft.com/some/path?query#fragment`.
	 * The part between the first double slashes and the next slash.</haxe_doc>
		</authority>
		<path public="1">
			<c path="String"/>
			<haxe_doc>* Path is the `/some/path` part of `http://www.msft.com/some/path?query#fragment`.</haxe_doc>
		</path>
		<query public="1">
			<c path="String"/>
			<haxe_doc>* Query is the `query` part of `http://www.msft.com/some/path?query#fragment`.</haxe_doc>
		</query>
		<fragment public="1">
			<c path="String"/>
			<haxe_doc>* Fragment is the `fragment` part of `http://www.msft.com/some/path?query#fragment`.</haxe_doc>
		</fragment>
		<fsPath public="1">
			<c path="String"/>
			<haxe_doc>* The string representing the corresponding file system path of this Uri.
	 *
	 * Will handle UNC paths and normalize windows drive letters to lower-case. Also
	 * uses the platform specific path separator. Will *not* validate the path for
	 * invalid characters and semantics. Will *not* look at the scheme of this Uri.</haxe_doc>
		</fsPath>
		<with public="1" set="method">
			<f a="change">
				<a>
					<scheme>
						<t path="Null"><c path="String"/></t>
						<meta><m n=":optional"/></meta>
					</scheme>
					<query>
						<t path="Null"><c path="String"/></t>
						<meta><m n=":optional"/></meta>
					</query>
					<path>
						<t path="Null"><c path="String"/></t>
						<meta><m n=":optional"/></meta>
					</path>
					<fragment>
						<t path="Null"><c path="String"/></t>
						<meta><m n=":optional"/></meta>
					</fragment>
					<authority>
						<t path="Null"><c path="String"/></t>
						<meta><m n=":optional"/></meta>
					</authority>
				</a>
				<c path="vscode.Uri"/>
			</f>
			<haxe_doc>* Derive a new Uri from this Uri.
	 *
	 * @param change An object that describes a change to this Uri. To unset components use `null` or
	 *  the empty string.
	 * @return A new Uri that reflects the given change. Will return `this` Uri if the change
	 *  is not changing anything.
	 * @sample ```
		let file = Uri.parse('before:some/file/path');
		let other = file.with({ scheme: 'after' });
		assert.ok(other.toString() === 'after:some/file/path');
		* ```</haxe_doc>
		</with>
		<toString public="1" set="method">
			<f a="?skipEncoding">
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<haxe_doc>* Returns a string representation of this Uri. The representation and normalization
	 * of a URI depends on the scheme. The resulting string can be safely used with
	 * [Uri.parse](#Uri.parse).
	 *
	 * @param skipEncoding Do not percentage-encode the result, defaults to `false`. Note that
	 *	the `#` and `?` characters occuring in the path will always be encoded.
		* @returns A string representation of this Uri.</haxe_doc>
		</toString>
		<toJSON public="1" set="method">
			<f a=""><x path="Any"/></f>
			<haxe_doc>* Returns a JSON representation of this Uri.
	 *
	 * @return An object.</haxe_doc>
		</toJSON>
		<haxe_doc>* A universal resource identifier representing either a file on disk
 * or another resource, like untitled resources.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"Uri"</e>
</m></meta>
	</class>
	<abstract path="vscode.ViewColumn" params="" file="src/vscode/ViewColumn.hx">
		<this><x path="Int"/></this>
		<haxe_doc>* Denotes a column in the VS Code window. Columns are
 * used to show editors side by side.</haxe_doc>
		<meta>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"ViewColumn"</e>
			</m>
			<m n=":enum"/>
		</meta>
		<impl><class path="vscode._ViewColumn.ViewColumn_Impl_" params="" file="src/vscode/ViewColumn.hx" private="1" module="vscode.ViewColumn" extern="1">
	<One public="1" set="null" static="1">
		<x path="vscode.ViewColumn"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</One>
	<Two public="1" set="null" static="1">
		<x path="vscode.ViewColumn"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Two>
	<Three public="1" set="null" static="1">
		<x path="vscode.ViewColumn"/>
		<meta>
			<m n=":enum"/>
			<m n=":impl"/>
		</meta>
	</Three>
	<meta>
		<m n=":final"/>
		<m n=":enum"/>
		<m n=":jsRequire">
			<e>"vscode"</e>
			<e>"ViewColumn"</e>
		</m>
	</meta>
</class></impl>
	</abstract>
	<class path="vscode._ViewColumn.ViewColumn_Impl_" params="" file="src/vscode/ViewColumn.hx" private="1" module="vscode.ViewColumn" extern="1">
		<One public="1" set="null" static="1">
			<x path="vscode.ViewColumn"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</One>
		<Two public="1" set="null" static="1">
			<x path="vscode.ViewColumn"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Two>
		<Three public="1" set="null" static="1">
			<x path="vscode.ViewColumn"/>
			<meta>
				<m n=":enum"/>
				<m n=":impl"/>
			</meta>
		</Three>
		<meta>
			<m n=":final"/>
			<m n=":enum"/>
			<m n=":jsRequire">
				<e>"vscode"</e>
				<e>"ViewColumn"</e>
			</m>
		</meta>
	</class>
	<typedef path="vscode.WorkspaceConfiguration" params="" file="src/vscode/WorkspaceConfiguration.hx">
		<a>
			<has set="method">
				<f a="section">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>* Check if this configuration has a certain value.
	 *
	 * @param section configuration name, supports _dotted_ names.
	 * @return `true` iff the section doesn't resolve to `undefined`.</haxe_doc>
			</has>
			<get params="T" set="method">
				<f a="section:?defaultValue">
					<c path="String"/>
					<c path="get.T"/>
					<c path="get.T"/>
				</f>
				<haxe_doc>* Return a value from this configuration.
	 *
	 * @param section Configuration name, supports _dotted_ names.
	 * @param defaultValue A value should be returned when no value could be found, is `undefined`.
	 * @return The value `section` denotes or the default.</haxe_doc>
			</get>
		</a>
		<haxe_doc>* Represents the workspace configuration. The workspace configuration
 * is always a merged view of the configuration of the current [workspace](#workspace.rootPath)
 * and the installation-wide configuration.</haxe_doc>
	</typedef>
	<class path="vscode.WorkspaceEdit" params="" file="src/vscode/WorkspaceEdit.hx" extern="1">
		<size public="1" set="null">
			<x path="Int"/>
			<haxe_doc>* The number of affected resources.
	 *
	 * @readonly</haxe_doc>
		</size>
		<replace public="1" set="method">
			<f a="uri:range:newText">
				<c path="vscode.Uri"/>
				<c path="vscode.Range"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Replace the given range with given text for the given resource.
	 *
	 * @param uri A resource identifier.
	 * @param range A range.
	 * @param newText A string.</haxe_doc>
		</replace>
		<insert public="1" set="method">
			<f a="uri:position:newText">
				<c path="vscode.Uri"/>
				<c path="vscode.Position"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Insert the given text at the given position.
	 *
	 * @param uri A resource identifier.
	 * @param position A position.
	 * @param newText A string.</haxe_doc>
		</insert>
		<delete public="1" set="method">
			<f a="uri:range">
				<c path="vscode.Uri"/>
				<c path="vscode.Range"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Delete the text at the given range.
	 *
	 * @param uri A resource identifier.
	 * @param range A range.</haxe_doc>
		</delete>
		<has public="1" set="method">
			<f a="uri">
				<c path="vscode.Uri"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Check if this edit affects the given resource.
	 * @param uri A resource identifier.
	 * @return `true` if the given resource will be touched by this edit.</haxe_doc>
		</has>
		<set public="1" set="method">
			<f a="uri:edits">
				<c path="vscode.Uri"/>
				<c path="Array"><c path="vscode.TextEdit"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Set (and replace) text edits for a resource.
	 *
	 * @param uri A resource identifier.
	 * @param edits An array of text edits.</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="uri">
				<c path="vscode.Uri"/>
				<c path="Array"><c path="vscode.TextEdit"/></c>
			</f>
			<haxe_doc>* Get the text edits for a resource.
	 *
	 * @param uri A resource identifier.
	 * @return An array of text edits.</haxe_doc>
		</get>
		<entries public="1" set="method">
			<f a=""><c path="Array"><x path="vscode.WorkspaceEditEntriesTuple"/></c></f>
			<haxe_doc>* Get all text edits grouped by resource.
	 *
	 * @return An array of `[Uri, TextEdit[]]`-tuples.</haxe_doc>
		</entries>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* A workspace edit represents textual changes for many documents.</haxe_doc>
		<meta><m n=":jsRequire">
	<e>"vscode"</e>
	<e>"WorkspaceEdit"</e>
</m></meta>
	</class>
	<abstract path="vscode.WorkspaceEditEntriesTuple" params="" file="src/vscode/WorkspaceEdit.hx" module="vscode.WorkspaceEdit">
		<this><c path="Array"><x path="Any"/></c></this>
		<to><icast><c path="Array"><x path="Any"/></c></icast></to>
		<meta><m n=":dce"/></meta>
		<impl><class path="vscode._WorkspaceEdit.WorkspaceEditEntriesTuple_Impl_" params="" file="src/vscode/WorkspaceEdit.hx" private="1" module="vscode.WorkspaceEdit">
	<uri public="1" get="accessor" set="null" static="1">
		<c path="vscode.Uri"/>
		<meta><m n=":impl"/></meta>
	</uri>
	<edits public="1" get="accessor" set="null" static="1">
		<c path="Array"><c path="vscode.TextEdit"/></c>
		<meta><m n=":impl"/></meta>
	</edits>
	<meta>
		<m n=":keep"/>
		<m n=":final"/>
		<m n=":dce"/>
		<m n=":dce"/>
	</meta>
</class></impl>
	</abstract>
	<typedef path="vscode.WorkspaceSymbolProvider" params="" file="src/vscode/WorkspaceSymbolProvider.hx">
		<a><provideWorkspaceSymbols set="method">
	<f a="query:token">
		<c path="String"/>
		<t path="vscode.CancellationToken"/>
		<x path="haxe.extern.EitherType">
			<c path="Array"><c path="vscode.SymbolInformation"/></c>
			<t path="js.Thenable"><c path="Array"><c path="vscode.SymbolInformation"/></c></t>
		</x>
	</f>
	<haxe_doc>* Project-wide search for a symbol matching the given query string. It is up to the provider
	 * how to search given the query string, like substring, indexOf etc.
	 *
	 * @param query A non-empty query string.
	 * @param token A cancellation token.
	 * @return An array of document highlights or a thenable that resolves to such. The lack of a result can be
	 * signaled by returning `undefined`, `null`, or an empty array.</haxe_doc>
</provideWorkspaceSymbols></a>
		<haxe_doc>* The workspace symbol provider interface defines the contract between extensions and
 * the [symbol search](https://code.visualstudio.com/docs/editor/editingevolved#_open-symbol-by-name)-feature.</haxe_doc>
	</typedef>
</haxe>